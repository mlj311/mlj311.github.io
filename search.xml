<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS之从面向对象的角度分析如何提高OC的代码质量]]></title>
    <url>%2F2018%2F11%2F07%2FiOS%E4%B9%8B%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98OC%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[从面向对象的角度分析如何提高OC的代码质量 理解“ 属性 ”这一概念属性（@property）是OC的一项特性 @property：编译器会自动生成实例变量和getter和setter方法 下文中，getter和setter方法合称为存取方法 For Example： 1@property (nonatomic, strong) UIView *qiShareView; 等价于 123@synthesize qiShareView = _qiShareView;- (UIView *)qiShareView;- (void)setQiShareView:(UIView *)qiShareView; 如果不希望自动生成存取方法和实例变量，那就要使用@dynamic关键字 1@dynamic qiShareView; 属性特质有四类： 1.原子性：默认为atomic nonatomic：非原子性，读写时不加同步锁 atomic：原子性，读写时加同步锁 2.读写权限：默认为readwrite readwrite：拥有getter和setter方法 readonly：仅拥有getter方法 3.内存管理： assign：对“纯量类型”做简单赋值操作（NSInteger、CGFloat等）。 strong：强拥有关系，设置方法 保留新值，并释放旧值。 weak：弱拥有关系，设置方法 不保留新值，不释放旧值。当指针指向的对象销毁时，指针置nil。 copy：拷贝拥有关系，设施方法不保留新值，将其拷贝。 unsafe_unretained：非拥有关系，目标对象被释放，指针不置为nil，这一点与assgin一样。区别于weak。 4.方法名： getter=：指定getter方法的方法名，常用 setter=：指定setter方法的方法名，不常用 例如： 1@property (nonatomic, getter=isOn) BOOL on; 在iOS开发中，99.99..%的属性都会声明为nonatomic。 一是atomic会严重影响性能， 二是atomic只能保证读/写操作的过程是可靠的，并不能保证线程安全。 二、在对象内部尽量直接访问实例变量1.实例变量（_属性名）访问对象的场景： 在init和alloc方法中，总是应该通过实例变量读写数据 没有重写setter和getter方法，也没有使用KVO监听 好处：不走OC方法的派发机制，直接访问内存读写，速度快，效率高 For Example： 123456789- (instancetype)initWithDic:(NSDictionary *)dic &#123; self = [super init]; if (self) &#123; _qi = dic[@&quot;qi&quot;]; _share = dic[@&quot;share&quot;]; &#125; return self;&#125; 2.用存取方法访问对象的场景： 重写getter/setter方法（比如：懒加载） 使用KVO监听值的改变 For Example： 123456- (UIView *)qiShareView &#123; if (!_qiShareView) &#123; _qiShareView = [UIView new]; &#125; return _qiShareView;&#125; 三、理解“对象等同性”12345NSString *aString = @&quot;iPhone 8&quot;;NSString *bString = [NSString stringWithFormat:@&quot;iPhone %i&quot;, 8];NSLog(@&quot;%d&quot;, [aString isEqual:bString]);NSLog(@&quot;%d&quot;, [aString isEqualToString:bString]);NSLog(@&quot;%d&quot;, aString == bString); 这段代码输出的是1；1；0。 ==操作符只是比较了两个指针所指对象的地址是否相同，而不是指针所指的对象的值。 所以最后一个为0。 四、以类族模式隐藏实现细节1234id maybeAnArray = @[];if ([maybeAnArray class] == [NSArray class]) &#123; //Code will never be executed&#125; 这个始终未false。原因：[maybeAnArray class]的返回永远不会是NSArray, NSArray是一个类族，返回的值一直都是NSArray的实体子类。大部分collection类都是某个类族中的抽象基类。 所以上面的if想要有机会执行的话要改成 1234id maybeAnArray = @[];if ([maybeAnArray isKindOfClass [NSArray class]) &#123; // Code probably be executed&#125; 这样判断的意思是，maybeAnArray这个对象是否是NSArray类族中的一员 使用类族的好处：可以把实现细节隐藏在一套简单的公共接口后面 五、在既有类中使用关联对象存放自定义数据先引入runtime类库1#import objc_AssociationPolicy（对象关联策略类型）: 三个方法管理关联对象：objc_setAssociatedObject（设置关联对象） 1234567891011/** * Sets an associated value for a given object using a given key and association policy. * * @param object The source object for the association. * @param key The key for the association. * @param value The value to associate with the key key for object. Pass nil to clear an existing association. * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.” */OBJC_EXPORT voidobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy) objc_getAssociatedObject（获得关联对象） 12345678910/** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. */OBJC_EXPORT id _Nullableobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) objc_removeAssociatedObjects（去除关联对象） 1234567891011121314/** * Removes all associations for a given object. * * @param object An object that maintains associated objects. * * @note The main purpose of this function is to make it easy to return an object * to a &quot;pristine state”. You should not use this function for general removal of * associations from objects, since it also removes associations that other clients * may have added to the object. Typically you should use \c objc_setAssociatedObject * with a nil value to clear an association. * */OBJC_EXPORT voidobjc_removeAssociatedObjects(id _Nonnull object) 小结： 可以通过“关联对象”机制可以把两个对象联系起来 定义关联对象可以指定内存管理策略 应用场景：只有在其他做法（代理、通知等）不可行时，才会选择使用关联对象。这种做法难于找bug。 六、理解objc_msgSend（对象的消息传递机制）首先我们要区分两个基本概念： 静态绑定（static binding）：在编译期就决定运行时所应调用的函数。代表语言：C、C++等 动态绑定（dynamic binding）：所要调用的函数直到运行期才能确定。代表语言：OC、swift等 OC是门强大的动态语言，它的动态性提现在它强大的runtime机制上。 解释：在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息后，由运行期决定究竟调用哪个方法，甚至可以在程序运行时改变，这些特性使得OC成为一门强大的动态语言。 底层实现：基于C语言函数实现。 实现的基本函数是objc_msgSend，定义如下： 1void objc_msgSend(id self, SEL cmd, ...) 这是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。 举例：git提交 1id return = [git commit:parameter]; 上面的方法会在运行时转换成如下的OC函数： 1id return = objc_msgSend(git, @selector(commit), parameter); objc_msgSend函数会在接收者所属的类中搜寻其方法列表，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。若是当前类没找到，那就沿着继承体系继续向上查找，等找到合适方法之后再跳转 ，如果最终还是找不到，那就进入消息转发（下一条具体展开）的流程去进行处理了。 可是如果每次传递消息都要把类中的方法遍历一遍，这么多消息传递加起来肯定会很耗性能。所以以下讲解OC消息传递的优化方法。 OC对消息传递的优化：快速映射表（缓存）优化： objc_msgSend在搜索这块是有做缓存的，每个OC的类都有一块这样的缓存，objc_msgSend会将匹配结果缓存在快速映射表(fast map)中，这样以来这个类一些频繁调用的方法会出现在fast map 中，不用再去一遍一遍的在方法列表中搜索了。 尾调用优化： 原理：在函数末尾调用某个不含返回值函数时，编译器会自动把栈空间的内存重新进行分配，直接释放所有调用函数内部的局部变量，存储调转至另一函数需要的指令码，然后直接进入被调用函数的地址。（从而不需要为调用函数准备额外的“栈帧”（frame stack）） 好处：最大限度的合理的分配使用的资源，避免过早发生栈溢出的现象。 （这一块偏底层，以上是小编的个人理解。路过的大神如果有更好的更深的见解，欢迎大神留言与我们讨论） 七、理解消息转发机制首先区分两个基本概念： 1 .消息传递：对象正常解读消息，传递过去（见上一条）。 2 .消息转发：对象无法解读消息，之后进行消息转发。 消息转发完整流程图： 流程解释： 第一步：调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。 第二步：调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。 第三步：调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。 最后：以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx 八、用“方法调配技术”调试“黑盒方法”方法调配（Method Swizzling）：使用另一种方法实现来替换原有的方法实现。（实际应用中，常用此技术向原有实现中添加新的功能。） 两个常用的方法： 获取给定类的指定实例方法： 1234567891011121314/** * Returns a specified instance method for a given class. * * @param cls The class you want to inspect. * @param name The selector of the method you want to retrieve. * * @return The method that corresponds to the implementation of the selector specified by * \e name for the class specified by \e cls, or \c NULL if the specified class or its * superclasses do not contain an instance method with the specified selector. * * @note This function searches superclasses for implementations, whereas \c class_copyMethodList does not. */OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name) 交换两种方法实现的方法： 12345678910111213141516/** * Exchanges the implementations of two methods. * * @param m1 Method to exchange with second method. * @param m2 Method to exchange with first method. * * @note This is an atomic version of the following: * \code * IMP imp1 = method_getImplementation(m1); * IMP imp2 = method_getImplementation(m2); * method_setImplementation(m1, imp2); * method_setImplementation(m2, imp1); * \endcode */OBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 利用这两个方法就可以交换指定类中的指定方法。在实际应用中，我们会通过这种方式为既有方法添加新功能。 For Example：交换method1与method2的方法实现 123Method method1 = class_getInstanceMethod(self, @selector(method1:));Method method2 = class_getInstanceMethod(self, @selector(method2:));method_exchangeImplementations(method1, method2); 九、理解“类对象”的用意Objective-C类是由Class类型来表示的，实质是一个指向objc_class结构体的指针。它的定义如下： 1typedef struct objc_class *Class; 在中能看到他的实现： 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; //!&lt; 指向metaClass(元类)的指针#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; //!&lt; 父类 const char * _Nonnull name OBJC2_UNAVAILABLE; //!&lt; 类名 long version OBJC2_UNAVAILABLE; //!&lt; 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; //!&lt; 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; //!&lt; 该类的实例变量大小 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; //!&lt; 该类的成员变量链表 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; //!&lt; 方法定义的链表 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; //!&lt; 方法缓存表 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; //!&lt; 协议链表#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 此结构体存放的是类的“元数据”（metadata)，例如类的实例实现了几个方法，父类是谁，具备多少实例变量等信息。 这里的isa指针指向的是另外一个类叫做元类（metaClass)。那什么是元类呢？元类是类对象的类。也可以换一种容易理解的说法： 1、当你给对象发送消息时，runtime处理时是在这个对象的类的方法列表中寻找 2、当你给类发消息时，runtime处理时是在这个类的元类的方法列表中寻找 我们来看一个很经典的图来加深理解： 可以总结如下： 1、每一个Class都有一个isa指针指向一个唯一的Meta Class（元类） 2、每一个Meta Class的isa指针都指向最上层的Meta Class，这个Meta Class是NSObject的Meta Class。(包括NSObject的Meta Class的isa指针也是指向的NSObject的Meta Class) 3、每一个Meta Class的super class指针指向它原本Class的 Super Class的Meta Class (这里最上层的NSObject的Meta Class的super class指针还是指向自己) 4、最上层的NSObject Class的super class指向 nil 转载地址]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>提高代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之ARC]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E4%B9%8BARC%2F</url>
    <content type="text"><![CDATA[ARC 内存管理ARC（自动引用计数）是iOS5、macOS10.7引入的内存管理技术，为了循序渐进的方式了解这项技术，本书先从ARC无效的环境说起，也就是常指的MRC（手动引用计数）环境。 内存管理的思考方式 自己生成的对象，自己所持有。 非自己生成的对象，自己也能持有。 不再需要自己持有的对象时释放。 非自己持有的对象无法释放。 这里的“自己”理解为编程人员自身。与“生成”、“持有”、“释放”操作并列的还有“废弃”，分别对应以下方法： 对象操作Objective-C方法生成并持有对象alloc/new/copy/mutableCopy等方法持有对象retain方法释放对象release方法废弃对象dealloc方法 注意：以上方法包含在Cocoa框架中而非Objective-C语言中。 自己生成的对象，自己所持有以下面名称开头的方法生成的对象为自己持有： alloc new copy mutableCopy 12id obj1 = [[NSObject alloc] init];// 自己生成并持有id obj2 = [NSObject new];// 自己生成并持有 另外，根据以上原则，下列方法也意味着自己生成并持有对象： allocMyObject newThatObject copyThis mutableCopyYourObject 1234567id obj = [MyObject allocMyObject]; // 内部实现+ (MyObject *)allocMyObject &#123; MyObject *obj = [[MyObject alloc] init]; return obj;&#125; 非自己生成的对象，自己也能持有alloc/new/copy/mutableCopy以外方法取得对象，非自己生成，自己不持有对象。可以通过retain方法为自己所持有。 12id obj = [NSMutableArray array];// 取得对象，但自己不持有[obj retain];// 自己持有对象 不再需要自己持有的对象时释放 自己持有的对象不再需要时，持有者有义务将其释放。释放使用release方法。 12id obj = [[NSObject alloc] init];// 自己生成并持有对象[obj release];// 释放对象 用retain方法持有对象，一旦不再需要，务必要用release方法释放。 123id obj = [NSMutableArray array];// 取得对象，但自己不持有[obj retain];// 持有非自己生成对象[obj release];// 释放对象 类似[NSMutableArray array]方法取得的对象存在，但自己不持有对象，内部如何实现？以object这个方法名为例： 12345- (id)object &#123; id obj = [[NSObject alloc] init];// 自己持有 [obj autorelease];// 适当时机自动释放 return obj;// 取得对象存在，但自己不持有&#125; autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放。 使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法是通过autorelease实现的。 非自己持有的对象无法释放用alloc/new/copy/mutableCopy方法生成并持有的对象，或用retain方法持有的对象，在不需要时要将其释放。倘若在应用程序中释放了非自己持有的对象会造成崩溃。 123456id obj = [[NSObject alloc] init];// 自己生成并持有对象[obj release];// 释放对象[obj release];// 重复释放对象，崩溃id obj1 = [obj0 object];// 取得对象，但自己不持有[obj1 release];// 释放非自己持有的对象，崩溃 alloc/retain/release/dealloc及其实现 Cocoa是macOS的系统框架，在iOS上被称为Cocoa Touch。Cocoa框架虽然没有公开，但是可以通过Cocoa框架的互换框架GNUstep来推测苹果的实现。 alloc调用allocWithZone，那么这里的参数类型NSZone是什么？ 它是为了防止内存碎片化而引入的结构。对内存分配的区域本身进行多重化的管理，根据使用对象的目的、对象的大小分配内存，从而提高内存管理的效率。 现在运行时系统中的内存管理已经极具效率，使用区域来管理内存反而会引起内存使用效率低下以及源代码复杂等问题。 GNUstep的实现GNUstep源码里alloc类方法用obj_layout结构体中的整数变量retained来保存引用计数retainCount，并将其写入对象内存头部。 执行alloc后对象的实例方法retainCount获得数值是1，retain使变量retained值+1，release使变量retained值-1。release使tetained变量大于0时-1，等于0时调用dealloc实例方法，废弃对象。 具体总结如下： 在Objective-C的对象中存有引用计数这一整数值。 调用alloc或是retain方法后，引用计数值+1。 调用release后，引用计数值-1。 引用计数值为0时，调用dealloc方法废弃对象。 苹果的实现alloc过程设置断点追踪调用的方法和函数： 1234+alloc+allocWithZone:class_createInstancecalloc//分配内存块 苹果对alloc的实现与GNUstep并无多大差异。 retainCount/retain/release调用的方法和函数分别如下： 1234567891011-retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey-retain__CFDoExternRefOperationCFBasicHashAddValue-release__CFDoExternRefOperationCFBasicHashRemoveValue （CEBasicHashRemoveValue返回0时，-release 调用dealloc） 可以从__CFDoExternRefOperation函数以及一些CFBasicHash开头的函数名看出，苹果的实现大概就是采用散列表（又称哈希表）来管理引用计数。 在引用计数表中，key为内存块地址，value为对应的引用计数，苹果这样实现的优势在于： 为对象分配内存块时无需考虑内存块头部。 对象占用内存块损坏时，可以根据引用计数表来确认内存块的位置。 检测内存泄露时，根据引用计数表中的记录检查对象的持有者是否存在。 autorelease及其实现autorelease会像C语言的自动变量那样对待对象实例。当超出其作用域时，对象实例的release实例方法被调用。 autorelease具体使用方法如下: 1.生成并持有NSAutoreleasePool对象； 2.调用已分配对象的autorelease实例方法； 3.废弃NSAutoreleasePool对象。 1234NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj release];[pool drain]; Cocoa框架中程序主循环的NSRunLoop对NSAutoreleasePool对象进行生成、持有和废弃处理。在大量产生autorelease对象时，若不废弃NSAutoreleasePool对象，那么生成的对象就不能被废弃，会产生内存不足现象。 GNUstep的实现autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法。 1[obj autorelease]; 源码： 123- (id)autorelease &#123; [NSAutoreleasePool addObject:self];&#125; GNUstep在实现NSAutoreleasePool时使用连接列表，可以理解为数组。若调用NSObject类的autorelease方法，该对象就会被追加到正在使用的NSAutoreleasePool对象的数组中。drain实例方法废弃正在使用的NSAutoreleasePool对象，会对数组中的所有对象调用release方法。 苹果的实现autoreleasepool以数组的形式实现，主要通过以下3个函数： obj_autoreleasePoolPush() obj_autorelease(obj) obj_autoreleasePoolPop(pool) 12345678910NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];/* 等同于objc_autoreleasePoolPush */ id obj = [[NSObject alloc] init]; [obj autorelease];/* 等同于 objc_autorelease(obj) */ [pool drain];/* 等同于 objc_autoreleasePoolPop(pool) */ ARCARC概述ARC（Auto Reference Counting）是iOS5、macOS10.7（OS X Lion）引入的内存管理技术。 ARC的出现解决了原来需要手动键入retain或release操作的问题。这在降低程序崩溃、内存风险的同时，很大程度上减少了开发程序的工作量。 内存管理的思考方式 “引用计数式内存管理”的本质在ARC中并没有改变，ARC只是自动地帮我们处理“引用计数”的相关部分。 所有权修饰符 ARC环境下其类型必须附加所有权修饰符（有省略的情况），所有权修饰符有以下4种： __strong __weak __unsafe_unretained __autorelease 书中此处提到id类型做一下记录： Objective-C中为了处理对象，可将变量定义为id类型，id类型用于隐藏对象类型的类名部分，相当于C语言中常用到的void *。 __strong修饰符id和对象类型默认使用__strong修饰，由于是默认情况，可省略不写。 __strong表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。 strong同weak、__autoreleasing一样，可以保证被修饰的变量在初始化时为nil。 1234id obj = [[NSObject alloc] init]; //等同于//id __strong obj = [[NSObject alloc] init]; __weak修饰符循环引用容易引起内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。使用__weak修饰符可以避免循环引用。 __weak表示弱引用，弱引用不能持有对象实例。 1id __weak obj = [[NSObject alloc] init];//编译器会警告 __weak修饰符还有另一个优点。在持有对象的弱引用时，若对象被废弃，则此弱引用将失效且处于nil被赋值的状态。 通过检查__weak修饰的变量是否为nil可以判断被赋值的对象是否已废弃。 weak只能用于iOS5和macOS10.7以上版本，在iOS4和macOS10.6及以前用unsafe_unretained代替。 __autoreleasing修饰符ARC下指定@autoreleasepool块来替代NSAutoreleasePool类生成、持有及废弃这一范围。_autoreleasing修饰变量等价于对象调用autorelease方法，即可将对象注册到autoreleasepool中。 123@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; 提问：前文提到__weak修饰的变量必须注册到autoreleasepool中，为什么？ 答：因为__weak修饰的变量只能持有对象的弱引用，在访问对象的过程中，该对象可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前能确保该对象存在。 _autoreleasing同__strong一样，显式使用罕见。 ARC的规则ARC环境下编译源代码遵循一定规则： 不能使用retain/release/retainCount/autorelease 不能使用NSAllocateObject/NSDeallocateObject ARC有效时，以上方法会导致编译器报错。 必须遵守内存管理的方法命名规则 对象的生成、持有的方法必须遵循命名规则：alloc/new/copy/mutableCopy。以init开头的方法更严格：必须是实例方法且必须返回对象，返回对象的类型必须是id类型或该方法声明类的对象类型。 不要显式调用dealloc dealloc方法无需显式调用，但C语言库需要在dealloc中free，以及删除已注册的通知观察者。 使用@autorelease块代替NSAutoreleasePool ARC有效时，使用@autoreleasepool块代替NSAutoreleasePool。 不能使用区域（NSZone） 不管ARC是否有效，区域在现在运行时系统中已单纯地被忽略。 C语言的规约上没有方法来管理结构体成员变量的生存周期。 对象型变量不能作为C语言结构体（struct/union）的成员 显式转换“id”和“void *” 123/* ARC无效 */id obj = [[NSObject alloc] init];void *p = obj ARC有效时需要通过__bridge来显式转换： 1234/* ARC有效 */id obj = [[NSObject alloc] init];void *p = (__bridge void*)obj;id o = (__bridge id)p; 属性和数组 声明属性所用的关键词与所有权修饰符的对应关系： 声明属性的关键词所有权修饰符 assign unsafe_unretained copy strong retain strong strong strong unsafe_unretained unsafe_unretained weak weak 动态数组中操作__strong修饰的变量与静态数组有很大差异，需要自己释放所有元素。静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，而在动态数组中，编译器不能确定数组的生存周期，所以无从处理。 ARC的实现__strong的实现 自己生成并持有 12345678&#123; id __strong obj = [[NSObject alloc] init];&#125;/* 编译器的模拟代码 */id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj); 非自己生成持有 123456id __strong obj = [NSMutableArray array];/* 编译器的模拟代码 */id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_release(obj); objc_retainAutoreleasedReturnValue函数用于持有对象，注册到autoreleasepool中并返回。与之对应的函数是objc_autoreleaseReturnValue。 12345678910+ (id)array &#123; return [[NSMutableArray alloc] init];&#125;/* 编译器的模拟代码 */+ (id)array &#123; id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 通过objc_retainAutoreleasedReturnValue函数和objc_autoreleaseReturnValue函数的协作，可以不将对象注册到autoreleasepool中而直接传递，以达到最优化程序运行。 __weak的实现 使用__weak修饰的变量，就是使用注册到autoreleasepool中的对象。 12345678910&#123; id __weak obj1 = obj;&#125;/* 编译器模拟代码 */id obj1;objc_initWeak(&amp;obj1, obj);id tmp = objc_loadWeakRetained(&amp;obj1);objc_autorelease(tmp);objc_destroyWeak(obj1); __weak同引用计数一样通过散列表（哈希表）实现，大致流程如下： 1.objc_initWeak(&amp;obj1, obj)函数初始化__weak修饰的变量，通过执行objc_storeWeak(&amp;obj1, obj)函数，以第一个参数（变量的地址）作为key，把第二个参数（赋值对象）作为value存入哈希表。 2.由于弱引用不能持有对象，函数objc_loadWeakRetained(&amp;obj1)取出所引用的对象并retain。 3.objc_autorelease(tmp)函数将对象注册到autoreleasepool中。 4.objc_destroyWeak(&amp;obj1)函数释放weak修饰的变量，通过过程执行objc_store(&amp;obj1, 0)函数，在weak表中查到变量地址并删除。废弃对象调用objc_clear_deallocating函数，这个过程会将weak表记录中weak修饰的变量地址赋值为nil。 如果大量使用weak修饰的变量，则会消耗相应的CPU资源。良策是只在需要避免循环引用时使用weak修饰符。 __autoreleasing的实现 12345678910@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125;/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelese(obj);objc_autoreleasePoolPop(); 以上为ARC篇的学习内容。]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之内存管理]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS之内存管理 #本篇的主题是iOS中的 “内存管理机制”。说到内存管理机制，逃不过iOS的两种内存管理机制：MRC 和 ARC。 先简单介绍一下：MRC（manual reference counting）：“手动引用计数” ，由开发者管理内存。ARC（automatic reference counting）：“自动引用计数”，从iOS 5开始支持，由编译器帮忙管理内存。 苹果引入ARC机制的原因猜测：iOS4之前，所有iOS开发者必须手动管理内存，即手动管理对象的内存分配和释放。首先，不断插入retain、release等内存管理语句，大大加大了工作量和代码量。其次，在面对一些多线程并发操作时，开发者手动管理内存并不简单，还可能会带来很多无法预知的问题。所以，苹果从iOS5开始引进ARC机制，由编译器帮忙管理内存。在编译期，编译器会自动加上内存管理语句。这样，开发者可以更加关注业务逻辑。 ##下面进入正题：内存管理。 一、理解引用计数引用计数工作原理： 这边引用我正在看的《Object-C 高级编程 iOS与OSX多线程和内存管理》这本书的例子： 经典例子： 解释：1、开灯：引申：“ 创建对象 ”。2、关灯：引申：“ 创建对象 ”。 解释：1、有人来上班打卡：开灯。– （创建对象，计数为1）2、又有人来：保持开灯。–（保持对象，计数为2）3、又有人来：保持开灯。–（保持对象，计数为3）4、有人下班了：保持开灯。–（保持对象，计数为2）5、又有人下班了：保持开灯。–（保持对象，计数为1）6、所有人都下班了：关灯。–（销毁对象，计数为0） 如果觉得本书中的例子说的有点抽象难懂，没关系，请看下面图解示例：提示：实箭头为强引用，虚箭头为弱引用 属性存取方法的内存管理 这边举一个set方法的例子： 解释：object中得到新值，_object存储着旧值。而set方法将保留新值，释放旧值，然后更新实例变量。这三个语句的顺序很重要。 如果先release再retain。那么该对象可能已经被回收，此时retain操作无效，因为对象已释放。这时实例变量就变成了悬挂指针。悬挂指针：指针指nil的指针。 自动释放池 在我们写iOS程序时，main函数里就有一个autoreleasepool（自动释放池）。 autorelease能延长对象的生命周期，在对象跨越“方法调用边界”后（就是}后）依然可以存活一段时间。 循环引用 循环引用（retain cycle）又称为“保留环”。形成循环引用的原因：是对象之间互相通过强指针指向对方（或者说互相强持有对方） 在开发中，我们不希望出现循环引用，因为会造成内存泄漏。 解决方案：有一方使用弱引用（weak reference）,解开循环引用，让多个对象得到释放。 PS：关于如何检验项目中是否有内存泄漏：1、静态内存泄漏分析方法；2、动态内存泄漏分析方法。 二、以ARC简化引用计数在ARC环境下，禁止调用：retain、release、autorelease、dealloc方法。 使用ARC时必须遵循的方法命名规则： 若方法名以alloc、new、copy、mutableCopy开头，则规定返回的对象归调用者。 变量的内存管理语义： 对比一下MRC和ARC在代码上的区别 MRC环境下： 这样会出现一种边界情况，如果新值和旧值是同一个对象，那么会先释放掉，object就变成悬挂指针。 ARC环境下： ARC会用一种更安全的方式解决边界问题：先保留新值，再释放旧值，最后更新实例变量。 同时，ARC可以通过修饰符来改变局部变量和实例变量的语义： ARC如何清理实例变量： MRC中，开发者需要在dealloc中动插入必要的清理代码（cleanup code）。 而ARC会借用Object-C++的一项特性来完成清理任务，回收OC++对象时，会调用C++的析构函数；走底层.cxx_destruct方法。而当释放OC对象时，ARC在.cxx_destruct底层方法中添加所需要的清理代码（这个方法底层的某个时机会调用dealloc方法）。 不过如果有非OC对象，还是需要写dealloc方法。比如CoreFoundation中的对象或是malloc()分配在堆中的内存依然需要清理。这时要适时调用CFRetain/CFRelease。 三、dealloc方法中只释放引用并解除监听调用dealloc方法时，对象已经处于回收状态了。这时不能调用其他方法，尤其是异步执行某些任务又要回调的方法。如果异步执行完回调的时候对象已经摧毁，会直接crash。 dealloc方法里要做些释放相关的事情，比如： 释放指向其他对象的引用。 取消订阅KVO。 取消NSNotification通知。 举个栗子: KVO: 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; //.... [webView addObserver:self forKeyPath:@&quot;canGoBack&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;canGoForward&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; self.backItem.enabled = self.webView.canGoBack; self.forwardItem.enabled = self.webView.canGoForward; self.title = self.webView.title; self.progressView.progress = self.webView.estimatedProgress; self.progressView.hidden = self.webView.estimatedProgress&gt;=1;&#125;- (void)dealloc &#123; [self.webView removeObserver:self forKeyPath:@&quot;canGoBack&quot;];//&lt; 移除KVO [self.webView removeObserver:self forKeyPath:@&quot;canGoForward&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;title&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;estimatedProgress&quot;];&#125; ``` * NSNotificationCenter: (void)viewDidLoad { //…… // 添加响应通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tabBarBtnRepeatClick) name:BQTabBarButtonDidRepeatClickNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(titleBtnRepeatClick) name:BQTitleButtonDidRepeatClickNotification object:nil];} // 移除通知 (void)dealloc { // [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTabBarButtonDidRepeatClickNotification object:nil];// [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTitleButtonDidRepeatClickNotification object:nil]; // 或者使用一个语句全部移除 [[NSNotificationCenter defaultCenter] removeObserver:self]; } ### 四、编写“ 异常安全代码 ”时留意内存管理问题 异常只应在发生严重错误后抛出。 用的不好会造成内存泄漏：在try块中，如果保留了某个对象，然后在释放它之前又抛出异常，那么除非catch块能解决问题，否则对象所占内存就会泄漏。 原因：C++的析构函数由Object-C的异常处理例程来运行。由于抛出异常会缩短生命周期，所以发生异常时必须析构，不然就内存泄漏，而这时如果文件句柄（file handle）等系统弄资源没有正确清理，就会发生内存泄漏。 捕获异常时，一定要将try块内所创立的对象清理干净。 ARC下，编译器默认不生成安全处理异常所需的清理代码。如要开启，请手动打开：-fobjc-arc-exceptions标志。但很影响性能。所以建议最好还是不要用。但有种情况是可以使用的:Object-C++模式。 PS:在运行期系统，C++与Object-C的异常互相兼容。也就是说其中任一语言抛出的异常，能用另一语言所编的“异常处理程序”捕获。而在编写Object-C++代码时，C++处理异常所用的代码与ARC实现的附加代码类似，编译器自动打开-fobjc-arc-exceptions标志，其性能损失不大。 最后，还是建议： * 异常只用于处理严重错误（fatal error，致命错误） * 对于一些不那么严重的错误（nofatal error，非致命错误）,有两种解决方案： 1、让对象返回nil或者0（例如：初始化的参数不合法，方法返回nil或0） 2、使用NSError ### 五、以弱引用避免循环引用（避免内存泄漏） * 为了避免因循环引用而造成内存泄漏。这时，某些引用需要设置为弱引用（weak） * 使用弱引用weak，ARC下，对象释放时，指针会置为nil。 ### 六、以 “自动释放池块” 降低内存峰值 * 默认情况下：自动释放池需要等待线程执行下一次事件循环时才清空，通常for循环会不断创建新对象加入自动释放池里，循环结束才释放。因此，可能会占用大量内存。 * 手动加入自动释放池子（@autoreleasepool）：每次for循环都会直接释放内存，从而降低了内存为峰值。 尤其，在遍历处理一些大数组或者大字典时，可以使用自动释放池来降低内存峰值，例如： NSArray qiShare = /一个很大的数组/NSMutableArray qiShareMembersArray = [NSMutableArray new];for (NSStirng name in qiShare) { @autoreleasepool { QiShareMember member = [QiShareMember alloc] initWithName:name]; [qiShareMembersArray addObject:member]; }}```PS：自动释放池的原理：排布在“栈”中，对象执行autorelease消息后，系统将其放入最顶端的池里（进栈），而清空自动释放池就是把对象销毁（出栈）。而调用出栈的时机：就是当前线程执行下一次事件循环时。 七、用 “僵尸对象” 调试内存管理问题 如上图，勾选这里可以开启僵尸对象设置。开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类（zombie class），变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序。 僵尸对象简单原理：在Objective-C的运行期程序库、Foundation框架以及CoreFoundation框架的底层加入了实现代码。在系统即将回收对象时，通过一个环境变量NSZombieEnabled识别是僵尸对象——不彻底回收，isa指针指向僵尸类并且响应所有选择子。 八、不要使用retainCount在苹果引入ARC之后retainCount已经正式废弃，任何时候都没法调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了（而且在ARC环境下也调用不了）。但是在MRC下还是可以正常使用的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS腾讯Bugly使用]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E8%85%BE%E8%AE%AFBugly%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#iOS腾讯Bugly使用 Bugly 创建 首先进入Bugly官网：Bugly官网,点击立即接入，用qq登陆后点击我的产品，新建一个产品，然后填写产品信息，保存 然后将Bugly集成到项目中，这里我用的是cocoapods 集成的Bugly pod &apos;Bugly&apos; 然后在工程中初始化Bugly，一句代码搞定APPID是必填的，在我的产品中点击设置获取 配置完成之后运行出现bug后就可以捕获异常了，在崩溃分析中查看，但是我们只看到了在哪个方法里里报错，并不知道崩溃具体在哪一行，所以我们还要配置符号表 关于符号表官网有详细介绍如何使用： 符号表 上传符号表：两种方式，分别是自动跟手动自动配置: 不需要java运行环境，在脚本里面填写相关信息， 直接在Xcode编译执行脚本即可，官网上有写，非常方便简单，但在编译的时候比较慢重点讲下手动配置： 官方的符号表工具iOS文档版­使用指南不是很通俗易懂，下面我再写一个更直观的教程，方便大家阅读。 配置环境 点击Java运行环境下载(JRE或JDK版本需要&gt;=1.6，我下的是9.0.4) 。 安装过后,查看是否安装成功，打开终端,在终端输入java -version 获取dSYM文件 dSYM文件是指具有调试信息的目标文件,在Products里面右击 Show in Finder 如图所示，如果编译后没有dSYM文件说明是Dug编译的，如果要在Debug环境也能成dSYM文件，所以要做如下设置: 实际项目中我没有设置，因为我是通过打包后获取的dSYM文件 生成符号表文件 3.1下载最新版Bugly iOS符号表工具 选一个位置创建一个文件夹，将”buglySymboliOS.jar”放入文件夹里面 ，我自己是在桌面创建了”testBugly”,然后将”buglySymboliOS.jar”放入进去了 最后使用JAR包跟dSYM在终端生成符号表文件 在终端执行以下命令:java -jar jar包路径 -i dSYM文件路径 上传符号表到到我产品。如图: 之前用自动符号表生成了一些，所以符号表文件有点多。 最后就可以在项目中愉快的看到bug出现在哪个类哪一行代码上了]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Bugly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode10升级后的问题]]></title>
    <url>%2F2018%2F11%2F05%2FXcode10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Xcode 10 Error 重复的info.plist文件删除掉多余的info.plist文件,重新编译即可(我是手动添加了Masonry的库,其中Masonry库中带有info.plist文件–删除) Multiple commands produce修改Xcode编译配置Xcode-&gt;File-&gt;Project Settings/Workspace Setting-&gt; Build System -&gt; Legacy Build System. Copy Pods Resources失效需要升级CocoaPods版本&gt;=1.4.0以上, 可见Github上的一个issues Xcode10 beta can’t load bundles from CocoaPods #解决ibrary not found for -lstdc++.6.0.9 真机：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/ 模拟器：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ 首先打开链接下载libstdc++.6.0.9.tbd；libstdc++.6.0.9.tbd下载地址密码：yc0m 进入到上述目录下，把libstdc++.6.0.9.tbd复制进去；]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之RN环境搭建]]></title>
    <url>%2F2018%2F10%2F10%2FiOS%E4%B9%8BRN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[React Native-iOS环境搭建 React Native 主要依赖以下环境: Mac OS X 操作系统 Xcode,推荐使用7.3.0或者更高系统 Node.js V6.2.1或者最新版本 Watchman和workflow NVM 下载Xcode，这个就不多讲了，直接在App Store下载即可安装Node.js，只要百度搜索Node.js，进入Node.js官网，直接下载安装Homebrew, 打开 Homebrew官网, 语言选择简体中文, 按照文档步骤进行安装即可打开终端依次输入命令：安装Homebrew:1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Node:123brew install node``` ### 安装Yarn npm install -g yarn react-native-cli1### 安装Watchman brew install watchman1### 安装Flow brew install flow12 brew update &amp;&amp; brew upgrade1### 安装NVM git clone https://github.com/creationix/nvm123``` cd nvm/``` ls123```source nvm.sh``` nvm123```nvm ls -remote N/A``` nvm ls12345## 环境搭建完毕 ## 创建项目 - 在桌面创建一个文件夹HelloWorld- 打开终端进入此文件夹（cd）- 终端输入: react-native init HelloWorld``` 在xcode中，使用快捷键cmd + R即可启动项目。基本的Xcode功能可以熟悉，比如模拟器的选择等。启动完成后，你会看到React-Packger和iOS模拟器，具体的效果如下，说明你创建项目成功了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F02%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[我的第一篇文章test – (实线) (虚线) 1.测试字体1.1测试字体(2018-2-6)本段为正文正文–（变斜）正文–（加粗），2018-2-8更新、本页跳转百度、本页跳转MacDown用法原链接。 分类：test 至 分类：learn 这两篇文章相隔甚久，期间发生了些什么呢，我也忘得差不多了，应该是在忙着开(fa)发(dai)吧😁。为啥开启第一篇呢，应该是过年将近，无需开发，只需光明正大的发呆就够了，嘻嘻嘻！第一篇文章我也不晓得写些啥子，但是还是想写，自从test文章结束后，我对于MacDown的用法还是非常陌生的，所以这次我还是先写(Command+C,Command+V)一篇MacDown的用法,当然上面也附上了原链接的地址，我可不是伸手党😝，为了给大家看看，主要还是为了自己之后写的时候还需要去百度，咦~~~，太low咯！！！ 2.下载链接 3.线框123线框第一行线框第二行线框第三行 4.列表无序列表 1(注意中间有空格) 2 3 有序列表 1(注意中间有空格) 2 3 5.连线5.1连线 1(注意中间有空格) 2 3 文字分割 5.2连线连线 1(注意中间有空格) 2 3 文字分割 前面有5个空格 5.3 连线 1(注意中间有空格) 2 3 6.表格第一行第一列第一行第二列第一行第三列第二行第一列第二行第二列,此格占2格第三行第一列，此格占3格 2018-2-8更新 1.删除效果删除 2.显示图片2.1显示网络图片2.2显示本地图片3.表格使用新方法： 第一列 第二列 第三列 aaaa bbbb cccc 4.代码显示：leftView = [[UIView alloc]init]; 5.表示引用 一盏灯，一片黄昏； 6.特殊符号hello ©文字居中]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaoLuJun 的博客]]></title>
    <url>%2F2018%2F01%2F02%2Fblog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客！！！ 博客内容工作所得工作：iOS开发，平时做项目的时候，都会事先写一个demo，然后在合并到项目中去。当项目完成后，会将demo放到博客中来，也当做一种工作记录。 生活所得生活：发呆的生活。。。。。。。。。。。 心情心情：。。。。 链接My GitHub]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>maolujun</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
