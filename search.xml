<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS之内存管理]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS之内存管理 #本篇的主题是iOS中的 “内存管理机制”。说到内存管理机制，逃不过iOS的两种内存管理机制：MRC 和 ARC。 先简单介绍一下：MRC（manual reference counting）：“手动引用计数” ，由开发者管理内存。ARC（automatic reference counting）：“自动引用计数”，从iOS 5开始支持，由编译器帮忙管理内存。 苹果引入ARC机制的原因猜测：iOS4之前，所有iOS开发者必须手动管理内存，即手动管理对象的内存分配和释放。首先，不断插入retain、release等内存管理语句，大大加大了工作量和代码量。其次，在面对一些多线程并发操作时，开发者手动管理内存并不简单，还可能会带来很多无法预知的问题。所以，苹果从iOS5开始引进ARC机制，由编译器帮忙管理内存。在编译期，编译器会自动加上内存管理语句。这样，开发者可以更加关注业务逻辑。 ##下面进入正题：内存管理。 一、理解引用计数引用计数工作原理： 这边引用我正在看的《Object-C 高级编程 iOS与OSX多线程和内存管理》这本书的例子： 经典例子： 解释：1、开灯：引申：“ 创建对象 ”。2、关灯：引申：“ 创建对象 ”。 解释：1、有人来上班打卡：开灯。– （创建对象，计数为1）2、又有人来：保持开灯。–（保持对象，计数为2）3、又有人来：保持开灯。–（保持对象，计数为3）4、有人下班了：保持开灯。–（保持对象，计数为2）5、又有人下班了：保持开灯。–（保持对象，计数为1）6、所有人都下班了：关灯。–（销毁对象，计数为0） 如果觉得本书中的例子说的有点抽象难懂，没关系，请看下面图解示例：提示：实箭头为强引用，虚箭头为弱引用 属性存取方法的内存管理 这边举一个set方法的例子： 解释：object中得到新值，_object存储着旧值。而set方法将保留新值，释放旧值，然后更新实例变量。这三个语句的顺序很重要。 如果先release再retain。那么该对象可能已经被回收，此时retain操作无效，因为对象已释放。这时实例变量就变成了悬挂指针。悬挂指针：指针指nil的指针。 自动释放池 在我们写iOS程序时，main函数里就有一个autoreleasepool（自动释放池）。 autorelease能延长对象的生命周期，在对象跨越“方法调用边界”后（就是}后）依然可以存活一段时间。 循环引用 循环引用（retain cycle）又称为“保留环”。形成循环引用的原因：是对象之间互相通过强指针指向对方（或者说互相强持有对方） 在开发中，我们不希望出现循环引用，因为会造成内存泄漏。 解决方案：有一方使用弱引用（weak reference）,解开循环引用，让多个对象得到释放。 PS：关于如何检验项目中是否有内存泄漏：1、静态内存泄漏分析方法；2、动态内存泄漏分析方法。 二、以ARC简化引用计数在ARC环境下，禁止调用：retain、release、autorelease、dealloc方法。 使用ARC时必须遵循的方法命名规则： 若方法名以alloc、new、copy、mutableCopy开头，则规定返回的对象归调用者。 变量的内存管理语义： 对比一下MRC和ARC在代码上的区别 MRC环境下： 这样会出现一种边界情况，如果新值和旧值是同一个对象，那么会先释放掉，object就变成悬挂指针。 ARC环境下： ARC会用一种更安全的方式解决边界问题：先保留新值，再释放旧值，最后更新实例变量。 同时，ARC可以通过修饰符来改变局部变量和实例变量的语义： ARC如何清理实例变量： MRC中，开发者需要在dealloc中动插入必要的清理代码（cleanup code）。 而ARC会借用Object-C++的一项特性来完成清理任务，回收OC++对象时，会调用C++的析构函数；走底层.cxx_destruct方法。而当释放OC对象时，ARC在.cxx_destruct底层方法中添加所需要的清理代码（这个方法底层的某个时机会调用dealloc方法）。 不过如果有非OC对象，还是需要写dealloc方法。比如CoreFoundation中的对象或是malloc()分配在堆中的内存依然需要清理。这时要适时调用CFRetain/CFRelease。 三、dealloc方法中只释放引用并解除监听调用dealloc方法时，对象已经处于回收状态了。这时不能调用其他方法，尤其是异步执行某些任务又要回调的方法。如果异步执行完回调的时候对象已经摧毁，会直接crash。 dealloc方法里要做些释放相关的事情，比如： 释放指向其他对象的引用。 取消订阅KVO。 取消NSNotification通知。 举个栗子: KVO: 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; //.... [webView addObserver:self forKeyPath:@&quot;canGoBack&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;canGoForward&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; self.backItem.enabled = self.webView.canGoBack; self.forwardItem.enabled = self.webView.canGoForward; self.title = self.webView.title; self.progressView.progress = self.webView.estimatedProgress; self.progressView.hidden = self.webView.estimatedProgress&gt;=1;&#125;- (void)dealloc &#123; [self.webView removeObserver:self forKeyPath:@&quot;canGoBack&quot;];//&lt; 移除KVO [self.webView removeObserver:self forKeyPath:@&quot;canGoForward&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;title&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;estimatedProgress&quot;];&#125;``` * NSNotificationCenter： (void)viewDidLoad { //…… // 添加响应通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tabBarBtnRepeatClick) name:BQTabBarButtonDidRepeatClickNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(titleBtnRepeatClick) name:BQTitleButtonDidRepeatClickNotification object:nil];} // 移除通知 (void)dealloc { // [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTabBarButtonDidRepeatClickNotification object:nil];// [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTitleButtonDidRepeatClickNotification object:nil]; // 或者使用一个语句全部移除 [[NSNotificationCenter defaultCenter] removeObserver:self]; } ### 四、编写“ 异常安全代码 ”时留意内存管理问题 异常只应在发生严重错误后抛出。 用的不好会造成内存泄漏：在try块中，如果保留了某个对象，然后在释放它之前又抛出异常，那么除非catch块能解决问题，否则对象所占内存就会泄漏。 原因：C++的析构函数由Object-C的异常处理例程来运行。由于抛出异常会缩短生命周期，所以发生异常时必须析构，不然就内存泄漏，而这时如果文件句柄（file handle）等系统弄资源没有正确清理，就会发生内存泄漏。 捕获异常时，一定要将try块内所创立的对象清理干净。 ARC下，编译器默认不生成安全处理异常所需的清理代码。如要开启，请手动打开：-fobjc-arc-exceptions标志。但很影响性能。所以建议最好还是不要用。但有种情况是可以使用的:Object-C++模式。 PS:在运行期系统，C++与Object-C的异常互相兼容。也就是说其中任一语言抛出的异常，能用另一语言所编的“异常处理程序”捕获。而在编写Object-C++代码时，C++处理异常所用的代码与ARC实现的附加代码类似，编译器自动打开-fobjc-arc-exceptions标志，其性能损失不大。 最后，还是建议： * 异常只用于处理严重错误（fatal error，致命错误） * 对于一些不那么严重的错误（nofatal error，非致命错误）,有两种解决方案： 1、让对象返回nil或者0（例如：初始化的参数不合法，方法返回nil或0） 2、使用NSError ### 五、以弱引用避免循环引用（避免内存泄漏） * 为了避免因循环引用而造成内存泄漏。这时，某些引用需要设置为弱引用（weak） * 使用弱引用weak，ARC下，对象释放时，指针会置为nil。 ### 六、以 “自动释放池块” 降低内存峰值 * 默认情况下：自动释放池需要等待线程执行下一次事件循环时才清空，通常for循环会不断创建新对象加入自动释放池里，循环结束才释放。因此，可能会占用大量内存。 * 手动加入自动释放池子（@autoreleasepool）：每次for循环都会直接释放内存，从而降低了内存为峰值。 尤其，在遍历处理一些大数组或者大字典时，可以使用自动释放池来降低内存峰值，例如： NSArray qiShare = /一个很大的数组/NSMutableArray qiShareMembersArray = [NSMutableArray new];for (NSStirng name in qiShare) { @autoreleasepool { QiShareMember member = [QiShareMember alloc] initWithName:name]; [qiShareMembersArray addObject:member]; }}```PS：自动释放池的原理：排布在“栈”中，对象执行autorelease消息后，系统将其放入最顶端的池里（进栈），而清空自动释放池就是把对象销毁（出栈）。而调用出栈的时机：就是当前线程执行下一次事件循环时。 七、用 “僵尸对象” 调试内存管理问题 如上图，勾选这里可以开启僵尸对象设置。开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类（zombie class），变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序。 僵尸对象简单原理：在Objective-C的运行期程序库、Foundation框架以及CoreFoundation框架的底层加入了实现代码。在系统即将回收对象时，通过一个环境变量NSZombieEnabled识别是僵尸对象——不彻底回收，isa指针指向僵尸类并且响应所有选择子。 八、不要使用retainCount在苹果引入ARC之后retainCount已经正式废弃，任何时候都没法调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了（而且在ARC环境下也调用不了）。但是在MRC下还是可以正常使用的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS腾讯Bugly使用]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E8%85%BE%E8%AE%AFBugly%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#iOS腾讯Bugly使用 Bugly 创建 首先进入Bugly官网：Bugly官网,点击立即接入，用qq登陆后点击我的产品，新建一个产品，然后填写产品信息，保存 然后将Bugly集成到项目中，这里我用的是cocoapods 集成的Bugly pod &apos;Bugly&apos; 然后在工程中初始化Bugly，一句代码搞定APPID是必填的，在我的产品中点击设置获取 配置完成之后运行出现bug后就可以捕获异常了，在崩溃分析中查看，但是我们只看到了在哪个方法里里报错，并不知道崩溃具体在哪一行，所以我们还要配置符号表 关于符号表官网有详细介绍如何使用： 符号表 上传符号表：两种方式，分别是自动跟手动自动配置: 不需要java运行环境，在脚本里面填写相关信息， 直接在Xcode编译执行脚本即可，官网上有写，非常方便简单，但在编译的时候比较慢重点讲下手动配置： 官方的符号表工具iOS文档版­使用指南不是很通俗易懂，下面我再写一个更直观的教程，方便大家阅读。 配置环境 点击Java运行环境下载(JRE或JDK版本需要&gt;=1.6，我下的是9.0.4) 。 安装过后,查看是否安装成功，打开终端,在终端输入java -version 获取dSYM文件 dSYM文件是指具有调试信息的目标文件,在Products里面右击 Show in Finder 如图所示，如果编译后没有dSYM文件说明是Dug编译的，如果要在Debug环境也能成dSYM文件，所以要做如下设置: 实际项目中我没有设置，因为我是通过打包后获取的dSYM文件 生成符号表文件 3.1下载最新版Bugly iOS符号表工具 选一个位置创建一个文件夹，将”buglySymboliOS.jar”放入文件夹里面 ，我自己是在桌面创建了”testBugly”,然后将”buglySymboliOS.jar”放入进去了 最后使用JAR包跟dSYM在终端生成符号表文件 在终端执行以下命令:java -jar jar包路径 -i dSYM文件路径 上传符号表到到我产品。如图: 之前用自动符号表生成了一些，所以符号表文件有点多。 最后就可以在项目中愉快的看到bug出现在哪个类哪一行代码上了]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Bugly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode10升级后的问题]]></title>
    <url>%2F2018%2F11%2F05%2FXcode10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Xcode 10 Error 重复的info.plist文件删除掉多余的info.plist文件,重新编译即可(我是手动添加了Masonry的库,其中Masonry库中带有info.plist文件–删除) Multiple commands produce修改Xcode编译配置Xcode-&gt;File-&gt;Project Settings/Workspace Setting-&gt; Build System -&gt; Legacy Build System. Copy Pods Resources失效需要升级CocoaPods版本&gt;=1.4.0以上, 可见Github上的一个issues Xcode10 beta can’t load bundles from CocoaPods #解决ibrary not found for -lstdc++.6.0.9 真机：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/ 模拟器：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ 首先打开链接下载libstdc++.6.0.9.tbd；libstdc++.6.0.9.tbd下载地址密码：yc0m 进入到上述目录下，把libstdc++.6.0.9.tbd复制进去；]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之RN环境搭建]]></title>
    <url>%2F2018%2F10%2F10%2FiOS%E4%B9%8BRN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[React Native-iOS环境搭建 React Native 主要依赖以下环境: Mac OS X 操作系统 Xcode,推荐使用7.3.0或者更高系统 Node.js V6.2.1或者最新版本 Watchman和workflow NVM 下载Xcode，这个就不多讲了，直接在App Store下载即可安装Node.js，只要百度搜索Node.js，进入Node.js官网，直接下载安装Homebrew, 打开 Homebrew官网, 语言选择简体中文, 按照文档步骤进行安装即可打开终端依次输入命令：安装Homebrew:1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Node:123brew install node``` ### 安装Yarn npm install -g yarn react-native-cli1### 安装Watchman brew install watchman1### 安装Flow brew install flow12 brew update &amp;&amp; brew upgrade1### 安装NVM git clone https://github.com/creationix/nvm123``` cd nvm/``` ls123```source nvm.sh``` nvm123```nvm ls -remote N/A``` nvm ls12345## 环境搭建完毕 ## 创建项目 - 在桌面创建一个文件夹HelloWorld- 打开终端进入此文件夹（cd）- 终端输入: react-native init HelloWorld``` 在xcode中，使用快捷键cmd + R即可启动项目。基本的Xcode功能可以熟悉，比如模拟器的选择等。启动完成后，你会看到React-Packger和iOS模拟器，具体的效果如下，说明你创建项目成功了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F02%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[我的第一篇文章test – (实线) (虚线) 1.测试字体1.1测试字体(2018-2-6)本段为正文正文–（变斜）正文–（加粗），2018-2-8更新、本页跳转百度、本页跳转MacDown用法原链接。 分类：test 至 分类：learn 这两篇文章相隔甚久，期间发生了些什么呢，我也忘得差不多了，应该是在忙着开(fa)发(dai)吧😁。为啥开启第一篇呢，应该是过年将近，无需开发，只需光明正大的发呆就够了，嘻嘻嘻！第一篇文章我也不晓得写些啥子，但是还是想写，自从test文章结束后，我对于MacDown的用法还是非常陌生的，所以这次我还是先写(Command+C,Command+V)一篇MacDown的用法,当然上面也附上了原链接的地址，我可不是伸手党😝，为了给大家看看，主要还是为了自己之后写的时候还需要去百度，咦~~~，太low咯！！！ 2.下载链接 3.线框123线框第一行线框第二行线框第三行 4.列表无序列表 1(注意中间有空格) 2 3 有序列表 1(注意中间有空格) 2 3 5.连线5.1连线 1(注意中间有空格) 2 3 文字分割 5.2连线连线 1(注意中间有空格) 2 3 文字分割 前面有5个空格 5.3 连线 1(注意中间有空格) 2 3 6.表格第一行第一列第一行第二列第一行第三列第二行第一列第二行第二列,此格占2格第三行第一列，此格占3格 2018-2-8更新 1.删除效果删除 2.显示图片2.1显示网络图片2.2显示本地图片3.表格使用新方法： 第一列 第二列 第三列 aaaa bbbb cccc 4.代码显示：leftView = [[UIView alloc]init]; 5.表示引用 一盏灯，一片黄昏； 6.特殊符号hello ©文字居中]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaoLuJun 的博客]]></title>
    <url>%2F2018%2F01%2F02%2Fblog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客！！！ 博客内容工作所得工作：iOS开发，平时做项目的时候，都会事先写一个demo，然后在合并到项目中去。当项目完成后，会将demo放到博客中来，也当做一种工作记录。 生活所得生活：发呆的生活。。。。。。。。。。。 心情心情：。。。。 链接My GitHub]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>maolujun</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
