<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ERPbug]]></title>
    <url>%2F2020%2F07%2F06%2FERPbug%2F</url>
    <content type="text"><![CDATA[ERPbug 在修改erp – bug所碰到的问题集锦父子组件以及非父子组件通信传参1.父组件传递数据给子组件父组件写法 123456789&lt;parent&gt; &lt;child :child-msg=&quot;msg&quot;&gt;&lt;/child&gt;//这里必须要用 - 代替驼峰&lt;/parent&gt;data()&#123; return &#123; msg: [1,2,3] &#125;;&#125; 子组件接收写法 1234567891011121314第一种：props: [&apos;childMsg&apos;]第二种：props: &#123; childMsg: Array //这样可以指定传入的类型，如果类型不对，会警告&#125;第三种：props: &#123; childMsg: &#123; type: Array, default: [0,0,0] //这样可以指定默认的值 &#125;&#125;可以根据自己的需要选择使用哪一种 2.子组件与父组件通信vue文档中是这么解释的：如果子组件想要改变数据呢？这在vue中是不允许的，因为vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的. 子组件写法 123456789&lt;template&gt; &lt;div @click=&quot;up&quot;&gt;&lt;/div&gt;&lt;/template&gt;methods: &#123; up() &#123; this.$emit(&apos;upup&apos;,&apos;hehe&apos;); //主动(dispatch)触发upup方法，&apos;hehe&apos;为向父组件传递的数据 &#125;&#125; 父组件写法 12345678&lt;div&gt; &lt;child @upup=&quot;change&quot; :msg=&quot;msg&quot;&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法&lt;/div&gt;methods: &#123; change(msg) &#123; this.msg = msg; &#125;&#125; 3.非父子组件通信vue文档中是这么解释的：如果2个组件不是父子组件那么如何通信呢？这时可以通过eventHub来实现通信. 所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件. 第一种： 1234创建一个公共的js，美其名曰：bus.js作为中间仓库来传值。//bus.jsimport Vue from &apos;vue&apos;export default new Vue() 组件A中 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; A组件: &apos;$emit&apos; 官网解释: ---事件触发器 &lt;span&gt;&#123;&#123;elementValue&#125;&#125;&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;点击触发&quot; @click=&quot;elementByValue&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入公共的bus，来做为中间传达的工具 import Bus from &apos;./bus.js&apos; export default &#123; data () &#123; return &#123; elementValue: 4 &#125; &#125;, methods: &#123; elementByValue: function () &#123; 通过事件中心去发射&apos;Assembly&apos;自己命名的，方法，this.elementValue为传的参数。 Bus.$emit(&apos;Assembly&apos;, this.elementValue) &#125; &#125; &#125;&lt;/script&gt; 组件B中 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; B组件: 通过$on方法来接受该方法以及传的参数 &lt;input type=&quot;button&quot; value=&quot;点击触发&quot; @click=&quot;getData&quot;&gt; &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Bus from &apos;./bus.js&apos; export default &#123; data () &#123; return &#123; name: 0 &#125; &#125;, mounted: function () &#123; var vm = this // 用$on事件来接收参数 并且调用了在a组件中出发的方法 Bus.$on(&apos;Assembly&apos;, (data) =&gt; &#123; console.log(data) vm.name = data &#125;) &#125;, methods: &#123; getData: function () &#123; this.name++ &#125; &#125; &#125;&lt;/script&gt; 这就完成了非父子组件的传参 数组、map集合的遍历element-ui dialog 无法关闭Vue变异方法push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 pop() 方法用于删除并返回数组的最后一个元素。 shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 sort() 方法用于对数组的元素进行排序。 reverse() 方法用于颠倒数组中元素的顺序。 替换数组filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 concat() 方法用于连接两个或多个数组。 slice() 方法可从已有的数组中返回选定的元素。 其他split() 方法用于把一个字符串分割成字符串数组。 VUE截取字符串12345678910111213141516171819let str = &apos;abcdef&apos;;// 0 str = str.slice(0);//返回整个字符串 abcdefstr = str.substring(0);//返回整个字符串 abcdefstr = str.substr(0);//返回整个字符串 abcdef// 使用一个参数str = str.slice(2);//截取第二个之后所有的字符 cdefstr = str.substring(2);//截取第二个之后所有的字符 cdefstr = str.substr(2);//截取第二个之后所有的字符 cdef // 使用两个参数str = str.slice(2,4);//截取第二个到第四个之间的字符 cdstr = str.substring(2,4);//截取第二个到第四个之间的字符 cdstr = str.substr(2,4);//截取从第3个开始往后数4位之间的字符 cdef // 使用两个负数str = str.slice(1,-3);//截取第二个到第四个之间的字符 bcstr = str.substring(1,-3);//截取第二个到第四个之间的字符 a #负数转换为0str = str.substr(1,-3);//不能为负数，若强行传递负数，会被当成0处理 &apos; &apos; #负数转换为0 vue 数组合并1234567891011121314treeData=[&#123; &apos;children&apos;: [], &apos;key&apos;: &apos;&apos;, &apos;title&apos;: &apos;全部&apos;, &apos;value&apos;: &apos;4&apos;&#125;]data.page=[ &#123; &apos;children&apos;: [], key&apos;: &apos;&apos;, &apos;title&apos;: &apos;全部&apos;, &apos;value&apos;: &apos;4&apos; &#125; ]treeData=treeData.concat( data.page) Array.isArray()Array.isArray() 用于确定传递的值是否是一个 Array。 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&quot;foobar&quot;); // falseArray.isArray(undefined); // false VUE学习笔记：数组的concat()、slice()和splice()concat()方法： concat()方法可以简单的将其理解为合并数组。基于当前数组中的所有项创建一个新数组。简单的说，concat()先给当前数组创建一个副本，然后将接收到的参数添加到这个副本（数组）的末尾，最后返回一个新的数组。来看个简单的示例： 1234var arr = [`大漠`,&apos;30&apos;,&apos;W3cplus&apos;];console.log(arr); // [&quot;大漠&quot;, &quot;30&quot;, &quot;W3cplus&quot;]var arr2 = arr.concat(&apos;Blog&apos;,&apos;2014&apos;);console.log(arr2); // [&quot;大漠&quot;, &quot;30&quot;, &quot;W3cplus&quot;, &quot;Blog&quot;, &quot;2014&quot;] 上面代码演示的concat()方法传递的值不是数组，这些值就会简单添加到结果数组(arr2)的末尾。 除此之外，concat()传递的值还有其他的使用方法：同时传递一个或多个数组，如下所示： 1234var arr = [&quot;大漠&quot;,&quot;30&quot;];console.log(arr); // [&quot;大漠&quot;, &quot;30&quot;]var arr2 = arr.concat(1,[&quot;blog&quot;,&quot;w3cplus&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]);console.log(arr2); // [&quot;大漠&quot;, &quot;30&quot;, 1, &quot;blog&quot;, &quot;w3cplus&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 另外,concat()还可以传递空值（也就是说没有传递参数），此时它只是复制当前数组，并且返回一个副本。如下所示： 1234var arr = [1,2];console.log(arr); // [1, 2]var arr2 = arr.concat();console.log(arr2); // [1, 2] 从上面几个示例，不难看出：concat()方法是在数组的副本上进行操作并返回新构建的数组，所以并不会影响到原来的数组。 concat() vs. push() 前面说过push()方法可以也可以给数组传参数，同样是在数组的末尾添加一个或多个值（数组）。那么与concat()有什么不同之处呢？别的先不多说，先来看一个示例： 12345678910111213// push()方法var arr = [&apos;a&apos;,&apos;b&apos;];console.log(arr); // [&quot;a&quot;, &quot;b&quot;]arr.push(&apos;c&apos;,&apos;d&apos;);console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] // concat()方法var arr = [&apos;a&apos;,&apos;b&apos;];console.log(arr); // [&quot;a&quot;, &quot;b&quot;]arr.concat(&apos;c&apos;,&apos;d&apos;);console.log(arr); // [&quot;a&quot;, &quot;b&quot;]var arr2 = arr.concat(&apos;c&apos;,&apos;d&apos;);console.log(arr2); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] Chrome输出的结果告诉我们：push()和concat()方法都可以将传的参数添加到数组的后面，只不过push()是在原数组上操作（改变的是原数组），concat()不会改变原数组，创建原数组的副本，并且把传的参数添加到新数组后面。 如果传的是数组又将是一个什么情形呢？还是看实例吧。 1234567891011// push()方法var arr = [&apos;a&apos;,&apos;b&apos;];console.log(arr); // [&quot;a&quot;, &quot;b&quot;]arr.push([&apos;c&apos;,&apos;d&apos;],[1,2,3]);console.log(arr); // [&quot;a&quot;, &quot;b&quot;, Array[2], Array[3]] // concat()var arr = [&apos;a&apos;,&apos;b&apos;];console.log(arr); // [&quot;a&quot;, &quot;b&quot;]var arr2 = arr.concat([&apos;c&apos;,&apos;d&apos;],[1,2,3]);console.log(arr2); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2, 3] push()传递的参数是数组时，将整个数组传给原数组末尾，如示例中得到的结果[“a”, “b”, Array[2], Array[3]]，而concat()传递的参数是数组时，将参数中数组的每一个数组项添加到原数组的末尾，如示例中得到的结果[“a”, “b”, “c”, “d”, 1, 2, 3]。 slice()方法: concat()方法可以在原数组基础上创建一个副本数组，其实slice()方法它也能基于当前数组创建一个新数组，而且对原数组也并不会有任何影响。 slice()接受一个或两个参数，即要返回项的起始和结束位置。当只给slice()传递一个参数时，该方法返回从该参数指定位置开始到当前数组末尾的所有项。如下面示例： 12345678910111213// 测试数组函数，将输出数组的length和第个key:valuevar test = function(array) &#123; console.log(&apos;length:&apos;+ array.length); array.forEach(function(element, index, array) &#123; console.log(index + &apos;:&apos; + element); &#125;);&#125;; var arr = [0,1,2,3,4,5,6];test(arr); var arr2 = arr.slice(3);test(arr);test(arr2); 假设将数组arr的每个数组项存放在一个小格子中，并且按数组的索引号从左向右存放。slice()方法执行之后，将会按传递的参数之前的值从格子中移除，如下图所示： slice()还可以传两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项，如： 12345var arr = [0,1,2,3,4,5,6];test(arr);var arr2 = arr.slice(2,5);test(arr);test(arr2); el-table 一行显示不下 …显示:show-overflow-tooltip=&quot;true&quot;]]></content>
      <categories>
        <category>erp</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020面试题]]></title>
    <url>%2F2020%2F07%2F01%2F2020%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2020面试题参考 1、说说runtime？一、基本概念 RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。 OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。 只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 二、怎么实现的 OC代码调用一个方法 1[self login] 在编译时RunTime会将上述代码转化成[发送消息] 1objc_msgSend(self,@selector(login)); 三、有什么作用 动态的添加对象的成员变量和方法 动态交换两个方法的实现 实现分类也可以添加属性 实现NSCoding的自动归档和解档 实现字典转模型的自动转换 2、SDWebImage实现原理是什么？ 它是如何解决tableView的复用时出现图片错乱问题的呢？一、SDWebImage实现原理是什么： 从内存(字典)中找图片(当这个图片在本次使用程序的过程中已经被加载过),找到直接使用 从沙盒中找(当这个图片在之前使用程序的过程中被加载过),找到使用,缓存到内存中. 从网络上获取,使用,缓存到内存,缓存到沙盒 简单来说就是 SDWebImage获取图片是 先从缓存中获取，如果获取不到的话，再去从网络上获取，网络上获取之后就会存放在内存以及沙盒中，之后再去此图片时就可以直接在内存中以及沙盒中获取 二、解决TableView服用时图片错乱出错问题： 每次都会调UIImageView+WebCache文件中的 [self sd_cancelCurrentImageLoad]; 3、描述下SDWebImage里面给UIImageView加载图片的逻辑？SDWebImage中为UIImageView+WebCache.h，这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage;会在真实图片出现前先显示占位图片，当真是图片被加载出来后再替换上占位图片。 加载图片的大致过程如下： 1、首先会在SDWebImageCache中寻找图片是否有对应的缓存，它会以url作为数据的索引仙子阿内存中寻找是否有响应的缓存2、如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据，如果找到了，就会把磁盘中的数据加载到内存中，并将图片显示出来3、如果内存和磁盘中都没有找到，那么就会向远程服务器发起请求，开始下载图片4、下载后的图片会加入到缓存，并写入磁盘5、整个获取图片的过程都在子线程中执行，获取图片后会到主线程将图片显示出来 SDWebImage原理：调用类别的方法： 从内存(字典)中找图片(当这个图片在本次使用程序的过程中已经被加载过),找到直接使用 从沙盒中找(当这个图片在之前使用程序的过程中被加载过),找到使用,缓存到内存中. 从网络上获取,使用,缓存到内存,缓存到沙盒 4、讲讲iOS事件响应链的原理？1、响应链通常是由视图（UIView）构成的2、一个视图的下一个响应者是它视图控制器（UIViewController），然后转给它的父视图（Super View）3、视图控制器的下一个响应者是为其管理的视图的父视图4、单例窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者（需要指出的是，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单点）5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环 5、说说多线程？一、多线程简述 线程是程序执行流的最小单元，一个线程包括：独有ID，程序计数器，寄存器集合，堆栈。同一进程可以有多个线程，它们共享进程的全局变量和堆数据。 这里的PC指向的是当前的指令地址，通过PC的更新来运行我们的程序，一个线程同一时刻只能执行一条指令。当然我们知道线程和进程都是虚拟概念，实际上PC是CPU核心的寄存器，它是实际存在的，所以也可以说一个CPU核心同一时刻只能执行一线程。 不管多处理器设备还是多核设备，开发者往往只需要关心CPU的核心数量，而不需要关心它们的物理构成。CPU核心数量是有限的，也就是说一个设备并发执行的线程数量有限的，当线程数量超过CPU核心数量时，一个CPU核心往往就要处理多个线程，这个行为叫做线程调度。 线程调度简单来说：一个CPU核心轮流让各个线程分别执行一段时间。当然这中间还包含着复杂的逻辑。 二、多线程的优化思路 1、减少队列切换 2、控制线程数量 3、线程优先级权衡 4、主线程任务优化 主线程任务的管理：内存复用、懒加载任务、任务拆分派对执行、主线程空闲时执行任务 三、关于“锁” 多线程会带来线程安全问题。当原子操作不能满足业务时，往往需要使用各种“锁”来保证内存的读写安全。 常用的锁：互斥锁、读写锁、空转锁、递归锁、同步锁，通常情况下，iOS开发中互斥锁 pthread_rwlock_t 就能满足大部分需求，且性能不错。```12345678910111213在读取锁失败时，线程可能有两种状态：* 空转状态：线程执行空任务循环等待，当锁可用时立即获取锁。* 挂起状态：线程挂起，当锁可用时需要其他线程唤醒。唤醒线程时比较耗时，线程空转需要消耗CPU资源并且时间越长消耗越多，由此可知空转适合少量任务，挂起适合大量任务。实际上互斥锁和读写锁都有空转锁的特性，它们在获取锁失败时会先空转一段时间，然后才会挂起，而空转锁也不会永远的空转，在特定的空转时间过后仍然会挂起，所以通常情况下不用刻意使用空转锁。1、OSSpinLock优先级反转问题2、```避免死锁：同一线程重复获取锁导致的死锁，这种情况可以使用递归锁来处理，pthread_mutex_t 使用 pthread_mutex_init_recursive() 方法初始化就能拥有递归锁的特性。 3、最小化临界区：将临界区尽量缩小，不会出现线程安全问题的代码就不要用锁来保护了，这样才能提高并发时锁的性能。 4、时刻注意不可重入方法的安全 5、编译器的过度优化：合理使用锁的地方仍然线程不安全，而volatile关键字就可以解决这类问题。 6、CPU 乱序执行 6、为什么刷新UI要在主线程操作？第一，为了安全以及效率 因为UIKit框架本身就不是线程安全的，如果多个线程进行UI操作，有可能出现资源抢夺，导致问题 第二，为了用户体验 iOS中只有主线程才能立即刷新UI。在子线程中是不能够更新UI，我们看到的子线程能够更新UI的原因是，等到子线程执行完毕，自动进入了主线程去执行子线程中更新UI的代码。由于子线程执行时间非常短暂，让我们误以为子线程可以更新UI。如果子线程一直在运行，则无法更新UI，因为没有办法进入主线程。 7、数据库操作FMDB有遇到什么问题吗？8、用定时器有遇到什么问题吗？9、说说用的架构？架构模式：MVC、MVVM、（MVP）反正万变不离MVC MCV：Model、View、Controller View – Controller – Model MVVM：Model、（View、ViewController）、ViewModel，基于 MVC 的，将网络请求，数据存储从ViewController剥离，写在ViewModel （View、ViewController）– ViewModel – Model 选用 MVVM 的架构模式来重构我们的APP 10、UIScrollView大概是如何实现的，它是如何区分是点击还是滑动手势？UIScrollView在滚动过程中，其实是在修改原点坐标。当手指触摸后，scrollView会暂时拦截触摸事件，使用一个计时器。假如当计时器到点时没有发生手指移动，那么scrollView则会发送tracking events到被点击的subView。假如计时器到点前发生移动事件，那么scrollView取消tracking自己发生滚动。假如计时器到点前未发生移动，到点后移动的话，则将一开始的触摸事件取消，也不会发生滑动。 11、网络层有封装吗？基于什么封装？封装了什么东西？当然有封装，基于AFNetworking 3.0 12、PerformSelector和runloop的关系当调用NSObject的 performSelecter:afterDelay: 后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop。所以当前线程没有RunLoop，则这个方法会失效；当调用 performSelector:onThread: 时，也会创建一个Timer加入到对应线程，同样，如果对应线程没有 RunLoop 该方法也会失效； 其他的performSelector系列方法是类似的，所以总结 PerformSelector 是依赖于RunLoop 13、KVO实现原理KVO是一个键值观察者模式，基于runtime机制实现的，当监听某个对象的某个属性时，KVO会创建这个对象的子类，并重写我们监听的属性的set方法。KVO是建立在KVC基础上的，可以看到，如果不通过KVC改变属性，那么set方法就不会执行，那么KVO也就没办法监听属性的变化了。 14、哪些情况下使用kvo会崩溃，怎么防护崩溃1、observer忘记写监听回调方法observerValueForKeyPath2、add和remover次数不一致3、被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。4、添加或者移除时 keypath == nil，导致崩溃。 防护：不要忘记写监听回调方法；add与remove次数一致；记得remove 15、block是类吗，有哪些类型block是类，类型有：globalBlock、stackBlock、mallocBlock 16、一个int变量被__block修饰与否的区别？没有修饰，被block捕获，是值拷贝使用__block修饰，会生成一个结构体，复制int的引用地址，达到修改数据 17、block在修改NSMutableArray，需不需要添加__block不需要 18、block解决循环引用时为什么要用strong、weak修饰__weak是为了防止循环引用 __strong是为了防止block持有的对象提前释放 19、iOS开发中有多少类型的线程？分别对比NSThread、NSOperation、GCD NSThread比其他两种较为轻量级，使用简单。但是，它需要自己管理线程生命周期，线程同步，加锁，睡眠以及唤醒等等。线程同步对数据的加锁会有一定的系统开销 NSOperation不需要关心线程管理，数据同步，可以把精力放在自己需要执行的操作上，NSOperation是面向对象 GCD是苹果开发的一个多核编程方案，iOS4+才能使用，替代NSThread、NSOperation的高效强大技术 20、GCD有哪些队列，默认提供哪些队列串行队列、并发队列、主队列、全局队列 21、iOS GCD 常用API1、Dispatch Queue 2、12343、Main Dispatch Queue/Global Dispatch Queue4、```diapatch_set_target_queue 5、12346、Dispatch Group7、```dispatch_barrier_async 8、```129、```dispatch_once 10、1211、```dispatch_suspend/dispatch_resume 12、Dispatch Semaphore 22、iOS GCD 线程同步方法一、dispatch_group 线程组 二、dispatch_barrier 栅栏块 三、dispatch_semaphore 信号量 23、dispatch_once实现原理dispatch_once主要是根据onceToken的值来决定怎么去执行代码。 1.当onceToken= 0时，线程执行dispatch_once的block中代码 2.当onceToken= -1时，线程跳过dispatch_once的block中代码不执行 3.当onceToken为其他值时，线程被阻塞，等待onceToken值改变 24、IOS开发 GCD产生死锁的总结了解死锁之前首先要明白几个常识： 1、同步与异步的区别在于能否“开启”新的线程 2、串行与并发的区别在于能否“同时”执行任务 3、把任务添加到队列[queue]中，按照“first in first out”原则执行任务 4、串行队列中执行任务特点：需要一个任务执行完毕之后，才能执行下一个任务，并发则不用。 5、同步执行任务是立即执行，异步则不是。 总结： 1、“同步”（sync）且在“当前队列【主线程】”（global）中执行任务，必定死锁 2、“同步”且在“同一个串行队列”中执行任务，必定死锁]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019问题集锦]]></title>
    <url>%2F2019%2F09%2F29%2F2019%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[2019 问题集锦 关于Xcode打包的时候出现的问题问题一：Code signing “AipBase.framework” failed.解决： 步骤1：在xcode中找到包含x86_64, i386的framework。如图所示序号4这里面的3个framework里面(AipBase.framewok,IdcardQuality.framework,AipOcrSdk.framework)都包含着x86_64, i386。 步骤2：用script命令去掉这3个framework里面不支持的x86_64, i386的结构 PS：序号10中粘贴的script命令如下 12345678910111213141516171819202122232425262728293031323334353637383940414243APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;# This script loops through the frameworks embedded in the application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdoecho &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done 参考：参考地址 问题二：更新了mac系统,想pod install 报错:zsh: /usr/local/bin/pod: bad interpreter: /System/Library/Frameworks/Ruby.framework解决:终端输入：sudo gem install -n /usr/local/bin cocoapods]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目修改名字以及修改BundleID]]></title>
    <url>%2F2019%2F09%2F27%2FiOS%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9%E5%90%8D%E5%AD%97%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9BundleID%2F</url>
    <content type="text"><![CDATA[iOS项目修改名字以及修改BundleID – 前言应公司要求，把做完的 iOS和Android APP的包名啊，项目名称要改掉才能上线。Fine，OK，改呗，反正iOS改起来so easy，安卓小哥坐不住了，改包名好麻烦的，设计到很多啥啥的，但是改项目名称就简单了；iOS刚好相反，妈耶，改包名如此简单，改项目名称就涉及好多好多诶。不管安卓了，先去改了再说~~ 参考链接:修改项目参考链接、修改BundleID参考连接 APP更改包名（BundleID）1、修改 info.plist 文件中的 Bundle identifier（改成你想要的那个Bundle identifier，如：com.example.xxx），编译通过后，此时你会发现个 project -&gt;Target -&gt;General 中的 Bundle identifier发生了变化，变成了 com.example.xxx。 2、修改 Project -&gt; Build Setting -&gt; Packaging -&gt; Produce Bundle Identifier OK,搞定了，嘻嘻嘻 APP更改项目名称注意：重命名项目时，记得先备份好一份！！！记得先备份好一份！！！记得先备份好一份！！！（重要的事情说三遍） 修改前项目架构路径截图（为了便于观察项目名字采用，修改前-修改后） 直接上图喔 步骤：（修改测试pod项目,xcode11） 1、在xcode修改项目名（点击按return键输入项目名字） 2、(在项目文件包里)修改项目文件夹名 这时候xcode会弹出提示框，选了colose（如下图） 继续修改文件里的文件夹名字（如下图三处地方） 3、修改项目文件名（双击选择显示包内容） 双击所指文件选择显示包内容 修改所指文件里的所有文件名 修改Podfile里的项目名 4、打开项目从新引入pod再把旧的pods文件删了（如下图） 修改完成后截图]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CoreData]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%AD%A6%E4%B9%A0CoreData%2F</url>
    <content type="text"><![CDATA[学习CoreData CoreData的简单理解 CoreData是一个模型层的技术，也是一种持久化技术，它能将模型对象的状态持久化到磁盘里，我们不需要使用SQL语句就能对它进行操作。 CoreData不是一个数据库但是可以使用数据库来存储数据，也可以使用其他方式，比如：数据库文件，XML，二进制文件，内存等。CoreData 提供了对象-关系映射(ORM) 功能。能够实现数据库数据和 OC 对象的相互转换，在这个转换过程中我们不需要编写任何 SQL 语句。 为什么要使用CoreData极大的减少Model层的代码量优化了使用SQLite时候的性能提供了可视化设计 CoreData的使用创建步骤 如果你是一个新的项目 可以创建项目的时候选择 CoreData 如图 如果是老的项目 之前没有使用CoreData ,则按照如下的步骤：第一步：先创建.xcdatamodeld文件 （右键 -&gt; New File -&gt; iOS -&gt; Core Data -&gt;Data Model） 第二步：命名然后创建（这里的名字要在后面操作的时候使用，要命好名字） 成功 新项目开始 创建 CodeDataMode 实体，并在实体中添加我们需要的键值 如图 使用相应的类 NSManagedObjectContext数据库操作：NSManagedObjectContext 被管理的对象上下文（对数据直接操作）NSManagedObjectContext：等同于一个容器，用来存储从数据库中转换出来的所有的 OC 对象。我们的增删改查操作直接对这个类使用来获得或者修改需要的 OC 对象，它能够调用 NSPersistentStoreCoordinator 类实现对数据库的同步，这个对象有点像SQLite对象(用来管理.xcdatamodeld中的数据)。负责数据和应用库之间的交互(CRUD，即增删改查、保存等接口都是用这个对象调用).每个 NSManagedObjectContext 和其他 NSManagedObjectContext 都是完全独立的。所有的NSManagedObject（个人理解：实体数据）都存在于NSManagedObjectContext中。每个NSManagedObjectContext都知道自己管理着哪些NSManagedObject（实体数据）可以通过TA去访问底层的框架对象集合，这些对象集合统称为持久化堆栈（persistence stack）——它在应用程序和外部数据存储的对象之间提供访问通道 NSManagedObjectNSManagedObject的工作模式有点类似于NSDictionary对象,通过键-值对来存取所有的实体属性. NSManagedObject：数据库中的数据转换而来的OC对象setValue:forkey:存储属性值(属性名为key);valueForKey:获取属性值(属性名为key).每个NSManagedObject都知道自己属于哪个NSManagedObjectContext 用于插入数据使用：获得实体，改变实体各个属性值，保存后就代表插入 NSEntityDescriptionNSEntityDescription 用来描述实体(Entity) 表格结构： 相当于数据库中的一个表，TA描述一种抽象数据类型通过Core Data从数据库中取出的对象,默认情况下都是NSManagedObject对象.+insertNewObjectForEntityForName:inManagedObjectContext: 工厂方法，根据给定的 Entity 描述，生成相应的 NSManagedObject 对象，并插入到 ManagedObjectContext 中LHModel * model = [NSEntityDescription insertNewObjectForEntityForName:@“CoreDataMode” inManagedObjectContext:self.managedObjectContext];通过上面的代码可以得到model这个表的实例，然后可以使用这个实例去为表中的属性赋值model.title = @“标题”;model.content = @“内容”; NSPersistentStoreCoordinatorNSPersistentStoreCoordinator 持久化存储库，CoreData的存储类型（比如SQLite数据库就是其中一种）。用来将对象管理部分和持久化部分捆绑在一起，负责相互之间的交流用来设置CoreData存储类型和存储路径使用 Core Data document 类型的应用程序，通常会从磁盘上的数据文中中读取或存储数据，这写底层的读写就由 Persistent Store Coordinator 来处理。一 般我们无需与它直接打交道来读写文件，Managed Object Context 在背后已经为我们调用 Persistent Store Coordinator 做了这部分工作NSPersistentStoreCoordinator：通过解析结果去实现数据库和 OC 对象之间的相互转换，主要是操作数据库的，我们一般用不上，由系统处理 NSManagedObjectModelNSManagedObjectModel Core Data的模型文件，有点像SQLite的.sqlite文件(个人理解：表示一个.xcdatamodeld文件)应用程序的数据模型，数据库中所有表格和他们之间的联系NSManagedObjectModel：负责读取解析 .momod 文件NSManagedObjectModel model = [self managedObjectModel];//获取实例NSDictionary entities = [model entitiesByName];//entitiesByName 得到所有的表的名字NSEntityDescription * entity = [entities valueForKey:@“CoreDataModel”];//从里面找出名为 Student 的表 具体实现 创建CoreDataManager 类CoreDataManager.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#import &lt;Foundation/Foundation.h&gt; #import &lt;CoreData/CoreData.h&gt; @interface CoreDataManager : NSObject /** * 上下文 容器 * 存放的是 所有从数据库中取出的转换成OC对象 */ @property (strong, nonatomic) NSManagedObjectContext * managedObjectContext; /* 读取解析 .momd文件中的内容 */@property (strong, nonatomic) NSManagedObjectModel * managedObjectModel; /* 连接的类，处理数据库数据和OC数据底层的相互转换 */@property (strong, nonatomic) NSPersistentStoreCoordinator * persistentStoreCoordinator; /** 单例 @return CoreDataManager */+ (instancetype)sharedInstance;+ /** 插入数据 @param dict 字典中的键值对必须要与实体中的每个名字一一对应 @param success 成功回调 @param fail 失败回调 */- (void)insertNewEntity:(NSDictionary *)dict success:(void(^)(void))success fail:(void(^)(NSError *error))fail; /** 查询数据 @param selectKays 数组高级排序（数组里存放实体中的key，顺序按自己需要的先后存放即可），实体key来排序 @param isAscending 升序降序 @param filterString 查询条件 @param filterString 成功回调 @param fail 失败回调 */- (void)selectEntity:(NSArray *)selectKays ascending:(BOOL)isAscending filterString:(NSString *)filterString success:(void(^)(NSArray *results))success fail:(void(^)(NSError *error))fail;/** 删除数据 @param model NSManagedObject @param success 成功回调 @param fail 失败回调 */- (void)deleteEntity:(NSManagedObject *)model success:(void(^)(void))success fail:(void(^)(NSError *error))fail;/** 更新数据 @param success 成功回调 @param fail 失败回调 */- (void)updateEntity:(void(^)(void))success fail:(void(^)(NSError *error))fail;@end``` CoreDataManager.m #import “CoreDataManager.h” //获取CoreData的.xcdatamodel文件的名称static NSString const coreDataModelName = @”CoreDataText”;//获取CodeDatastatic NSString const coreDataEntityName = @”CoreDataMode”;//数据库static NSString * const sqliteName = @”CoreDataMode.sqlite”;@interface CoreDataManager() @end @implementation CoreDataManager@synthesize managedObjectContext = _managedObjectContext;@synthesize managedObjectModel = _managedObjectModel;@synthesize persistentStoreCoordinator = _persistentStoreCoordinator; static CoreDataManager *coreDataManager = nil; (instancetype)sharedInstance{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ coreDataManager = [[CoreDataManager alloc] init]; }); return coreDataManager;} (instancetype)allocWithZone:(struct _NSZone *)zone{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ if (coreDataManager == nil) { coreDataManager = [super allocWithZone:zone]; } }); return coreDataManager;} (void)insertNewEntity:(NSDictionary )dict success:(void (^)(void))success fail:(void (^)(NSError ))fail { if (!dict||dict.allKeys.count == 0) return; // 通过传入上下文和实体名称，创建一个名称对应的实体对象（相当于数据库一组数据，其中含有多个字段） NSManagedObject entity = [NSEntityDescription insertNewObjectForEntityForName:coreDataEntityName inManagedObjectContext:self.managedObjectContext]; // 实体对象存储属性值（相当于数据库中将一个值存入对应字段) for (NSString key in [dict allKeys]) { [entity setValue:[dict objectForKey:key] forKey:key]; } // 保存信息，同步数据 NSError *error = nil; BOOL result = [self.managedObjectContext save:&amp;error]; if (!result) { NSLog(@&quot;添加数据失败：%@&quot;,error); if (fail) { fail(error); } } else { NSLog(@&quot;添加数据成功&quot;); if (success) { success(); } }} (void)deleteEntity:(NSManagedObject )model success:(void (^)(void))success fail:(void (^)(NSError ))fail { // 传入需要删除的实体对象 [self.managedObjectContext deleteObject:model]; // 同步到数据库 NSError *error = nil; [self.managedObjectContext save:&amp;error]; if (error) { NSLog(@&quot;删除失败：%@&quot;,error); if (fail) { fail(error); } } else { NSLog(@&quot;删除成功&quot;); if (success) { success(); } }} (void)selectEntity:(NSArray )selectKays ascending:(BOOL)isAscending filterString:(NSString )filterString success:(void (^)(NSArray ))success fail:(void (^)(NSError ))fail { // 1.初始化一个查询请求 NSFetchRequest request = [[NSFetchRequest alloc] init]; // 2.设置要查询的实体 NSEntityDescription desc = [NSEntityDescription entityForName:coreDataEntityName inManagedObjectContext:self.managedObjectContext]; request.entity = desc; // 3.设置查询结果排序 if (selectKays&amp;&amp;selectKays.count&gt;0) { // 如果进行了设置排序 NSMutableArray *array = [NSMutableArray array]; for (NSString *key in selectKays) { /** * 设置查询结果排序 * sequenceKey:根据某个属性（相当于数据库某个字段）来排序 * isAscending:是否升序 */ NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:key ascending:isAscending]; [array addObject:sort]; } if (array.count&gt;0) { request.sortDescriptors = array;// 可以添加多个排序描述器，然后按顺序放进数组即可 } } // 4.设置条件过滤 if (filterString) { // 如果设置了过滤语句 NSPredicate *predicate = [NSPredicate predicateWithFormat:filterString]; request.predicate = predicate; } // 5.执行请求 NSError error = nil; NSArray objs = [self.managedObjectContext executeFetchRequest:request error:&amp;error]; // 获得查询数据数据集合 if (error) { NSLog(@&quot;失败&quot;); if (fail) { fail(error); } } else{ NSLog(@&quot;成功&quot;); if (success) { success(objs); } }} (void)updateEntity:(void (^)(void))success fail:(void (^)(NSError ))fail { NSError error = nil; [self.managedObjectContext save:&amp;error]; if (error) { NSLog(@&quot;删除失败：%@&quot;,error); if (fail) { fail(error); } } else { if (success) { success(); } }} #pragma 懒加载//managedObjectModel 属性的getter方法-(NSManagedObjectModel )managedObjectModel{ if (_managedObjectModel != nil) return _managedObjectModel; //.xcdatamodeld文件 编译之后变成.momd文件 （.mom文件） NSURL modelURL = [[NSBundle mainBundle] URLForResource:coreDataModelName withExtension:@”momd”]; //把文件的内容读取到managedObjectModel中 _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; return _managedObjectModel;} //Coordinator 调度者负责数据库的操作 创建数据库 打开数据 增删改查数据-(NSPersistentStoreCoordinator )persistentStoreCoordinator{ if (_persistentStoreCoordinator != nil) return _persistentStoreCoordinator; //根据model创建了persistentStoreCoordinator _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; // 设置数据库存放的路径 NSURL storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:sqliteName]; NSError error = nil; //如果没有得到数据库，程序崩溃 / 持久化存储库的类型： NSSQLiteStoreType SQLite数据库 NSBinaryStoreType 二进制平面文件 NSInMemoryStoreType 内存库，无法永久保存数据 虽然这3种类型的性能从速度上来说都差不多，但从数据模型中保留下来的信息却不一样 在几乎所有的情景中，都应该采用默认设置，使用SQLite作为持久化存储库 */ // 添加一个持久化存储库并设置类型和路径，NSSQLiteStoreType：SQLite作为存储库 if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) { if (error) { NSLog(@”添加数据库失败:%@”,error); } else { NSLog(@”添加数据库成功”); } NSLog(@”错误信息: %@, %@”, error, [error userInfo]); } return _persistentStoreCoordinator;} -(NSURL *)applicationDocumentsDirectory{ //获取沙盒路径下documents文件夹的路径 NSURL (类似于search) NSLog(@”%@”,[[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject].absoluteString); return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];} //容器类 存放OC的对象-(NSManagedObjectContext )managedObjectContext{ if (_managedObjectContext != nil) return _managedObjectContext; NSPersistentStoreCoordinator coordinator = [self persistentStoreCoordinator]; if (!coordinator) { return nil; } //创建context对象 _managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType]; //让context和coordinator关联 context可以对数据进行增删改查功能 // 设置上下文所要关联的持久化存储库 [_managedObjectContext setPersistentStoreCoordinator:coordinator]; return _managedObjectContext;}@end123## 5、具体使用* 增 insert NSDictionary dict = @{@”title”:@”title2”,@”content”:@”content2”}; [[CoreDataManager sharedInstance] insertNewEntity:dict success:^{ NSLog(@”成功”); } fail:^(NSError error) { NSLog(@”失败”); }]; 1运行结果 ： 2018-11-12 13:25:06.730756+0800 CoreDataText[1600:1182994] 添加数据成功 123456数据库中显示： ![7][link7] * 查询 select [[CoreDataManager sharedInstance] selectEntity:nil ascending:YES filterString:nil success:^(NSArray results) { NSLog(@”数据—%@”,results); } fail:^(NSError error) { }];12345678运行结果： ![8][link8] ![9][link9]* 改 updata [[CoreDataManager sharedInstance] selectEntity:nil ascending:YES filterString:nil success:^(NSArray results) { NSLog(@”数据—%@”,results); if (results.count&gt;0) { //更新某个 NSManagedObject model = [results firstObject]; [model setValue:@”xiugaile title” forKey:@”title”]; [model setValue:@”xiugaile content” forKey:@”content”]; [[CoreDataManager sharedInstance] updateEntity:^{ } fail:^(NSError error) { }]; }} fail:^(NSError error) { }];12345678运行结果 ：![10][link10] ![11][link11]* 删除 delete //删除某个NSString filterString = [NSString stringWithFormat:@”title = ‘title’”];[[CoreDataManager sharedInstance] selectEntity:nil ascending:YES filterString:filterString success:^(NSArray results) { NSLog(@”数据—%@”,results); if (results.count&gt;0) { //删除某个 [[CoreDataManager sharedInstance] deleteEntity:[results firstObject] success:^{ } fail:^(NSError *error) { }]; } } fail:^(NSError error) {}];//全部删除[[CoreDataManager sharedInstance] selectEntity:nil ascending:YES filterString:nil success:^(NSArray results) { NSLog(@”数据—%@”,results); //全部删除 for (NSManagedObject obj in results){ [[CoreDataManager sharedInstance] deleteEntity:obj success:^{ } fail:^(NSError error) { }]; }} fail:^(NSError *error) { }];``` 运行结果： 转载自CoreData]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019亲身面试所得]]></title>
    <url>%2F2019%2F08%2F21%2F2019%E4%BA%B2%E8%BA%AB%E9%9D%A2%E8%AF%95%E6%89%80%E5%BE%97%2F</url>
    <content type="text"><![CDATA[2019亲身面试所得 8.21iOS-NSThread、NSOperation和GCD区别 NSThread：优点：NSThread 比其他两个轻量级，使用简单缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销 NSOperation：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上NSOperation是面向对象的 GCD：Grand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术 iOS性能优化卡顿优化： 尽可能减少CPU、GPU资源消耗 按照60FPS的刷帧率，每隔16ms就会有一次VSync信号 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout会比直接设置frame消耗更多的CPU资源 图片的size最好刚好跟UIImageView的size保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES 尽量避免出现离屏渲染 iOS - 内存管理(ARC) 引用计数：引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 ARC的内存管理ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外还有 10% 内存管理，是需要开发者自己处理的，这主要就是与底层 Core Foundation 对象交互的那部分，底层的 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。内存管理问题1.循环引用(block,代理)2.Core Foundation 对象需要手动管理计数器 iOS强引用与弱引用 强引用ARC中修饰符是strong，比如 strong NSObject *obj; 弱引用在ARC中修饰符是weak，比如 weak NSObject *obj; 两者区别简单点讲的话，强引用持有对象，而弱引用不持有对象。 应用平时一般都是用strong，也就是默认不添加，在会照成循环引用时才使用weak。当两个不同的对象各有一个强引用指向对方时就造成循环引用，会导致对象无法释放.这时我们得用weak（MRC的话是用assign），代理（delegate）和block很容易造成循环引用。 WebView的使用主要重点还是webView与JS交互： 1.加载webview 2.webview的代理方法：// 当点击页面进行加载数据的时候调用- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType;// 当页面开始加载的时候调用- (void)webViewDidStartLoad:(UIWebView )webView;// 当页面加载完成的时候调用- (void)webViewDidFinishLoad:(UIWebView )webView;// 页面加载失败的时候调用- (void)webView:(UIWebView )webView didFailLoadWithError:(NSError )error; 3.交互：1、拦截url ；2、注册OC与js方法 ； 3、桥接机制 iOS 如何高效的使用多线程以及对多线程的理解一、如何高效的使用多线程 减少队列切换 控制线程数量 线程优先级权衡 主线程任务的优化：内存复用、懒加载任务、任务拆分排队执行、主线程空闲时执行任务 二、多线程的理解 1、多线程： 一个进程中可以开启多条线程，每个线程可以并发（同时）执行不同的任务； 多线程可以提高任务的执行效率 2、多线程的原理： 同一时间，CPU只能处理一条线程，只有一条线程在执行（单核） 多线程并发（同时）执行，其实是CPU快速的在多条线程之间调度（切换） 如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象 如果线程非常多，会导致CPU在很多的线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低） 3、多线程的优缺点 优点：1、能适当提高程序的执行效率2、能适当提高资源利用率（CPU，内存利用率） 缺点：1、创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1kb），栈空间（子线程512kb，主线程1mb，也可以使用-setStackSize:设置，但必须是4k的倍数，而且最小是16k），创建线程大约需要90毫秒的创建时间2、如果开启大量的线程，会降低程序的性能3、线程越多，CPU在调度线程上的开销就越大4、程序设计更加复杂，比如线程之间的通信，多线程的数据共享 多线程在iOS开发中的应用1、主线程：一个iOS程序运行后，默认会开启一条线程，称为主线程或UI线程2、主线程的主要作用：1.显示／刷新UI界面 2.处理UI事件（比如点击事件，滚动事件，拖拽事件等）3、主线程的使用注意：1.不要将比较耗时的操作放到主线程中 2.耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验4、耗时操作的执行：将耗时操作放在子线程（后台线程，非主线程）5、获得主线程：NSThread main=[NSThread mainThread];6、获得当前线程：NSThread current=[NSThread currentThread];7、判断是否是主线程：1.number==1? 2.类方法 ：BOOL isMain= [NSThread isMainThread]; 3.对象方法：BOOL ifMain=[current isMainThread]; ios网络请求时,如何保证网络安全1.https: 2.token 3.post请求 4.加密 base64, MD5 登录注册使用 加盐+再次MD5加密 a.对称加密 同一个秘钥 b.非对称加密 公钥私钥 RSA 支付宝支付使用 c.钥匙串存储 keychain iOS常见的几种加密方法 base64加密 POST加密 Token值（登录令牌） MD5加密–(信息-摘要算法) 哈希算法之一 时间戳密码 钥匙串访问 指纹识别 iOS网络请求安全 Base64编码 MD5散列 HTTPS请求 iOS界面布局的几种方式 这是最简单的布局方式，在UI控件初始化时通过- （void）initWithFrame进行设置，或者在init之后在进行设置 使用AutoLayout进行页面布局 Masonry：布局库轻量、简便、功能强大 autoresizing 对称加密和非对称加密的区别？分别有哪些算法的实现？对称加密与非对称加密： 对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。 常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。 http和https的区别HTTPS是HTTP的安全版，在HTTP的基础上加入SSL层(Secure Socket Layer 安全套接字)，对数据传输（客户端发送数据和服务器响应数据）进行加密和身份验证，广泛用于网络通讯，如交易和支付。 HTTPS和HTTP的区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全。 8.22ios 线程间通信 什么叫做线程间通信 在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信 线程间通信的体现 1个线程传递数据给另1个线程，1个线程传递数据给另1个线程 线程间通信常用方法 -(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; -void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; iOS 中几种常用的锁总结多线程编程中，应该尽量避免资源在线程之间共享，以减少线程间的相互作用。 但是总是有多个线程相互干扰的情况（如多个线程访问一个资源）。在线程必须交互的情况下，就需要一些同步工具，来确保当它们交互的时候是安全的。 锁是线程编程同步工具的基础。iOS开发中常用的锁有如下几种： @synchronized NSLock 对象锁 NSRecursiveLock 递归锁 NSConditionLock 条件锁 pthread_mutex 互斥锁（C语言） dispatch_semaphore 信号量实现加锁（GCD） OSSpinLock （暂不建议使用，原因参见这里） @synchronized 关键字加锁 互斥锁，性能较差不推荐使用`@synchronized(这里添加一个OC对象，一般使用self) { 这里写要加锁的代码 }`注意点: 加锁的代码尽量少 添加的OC对象必须在多个线程中都是同一对象 优点是不需要显式的创建锁对象，便可以实现锁的机制。 @synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 NSLock 互斥锁 不能多次调用 lock方法,会造成死锁在Cocoa程序中NSLock中实现了一个简单的互斥锁。 所有锁（包括NSLock）的接口实际上都是通过NSLocking协议定义的，它定义了lock和unlock方法。你使用这些方法来获取和释放该锁。 NSLock类还增加了tryLock和lockBeforeDate:方法。 tryLock试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程，相反，它只是返回NO。 lockBefore lockBeforeDate:方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会让线程从阻塞状态变为非阻塞状态（或者返回NO）。 NSRecursiveLock 递归锁 使用锁最容易犯的一个错误就是在递归或循环中造成死锁。 NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会造成死锁。 递归锁会跟踪它被多少次lock。每次成功的lock都必须平衡调用unlock操作。 只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线程获得。 NSConditionLock 条件锁 在线程1中的加锁使用了lock，是不需要条件的，所以顺利的就锁住了。 unlockWithCondition:在开锁的同时设置了一个整型的条件 2 。 线程2则需要一把被标识为2的钥匙，所以当线程1循环到 i = 2 时，线程2的任务才执行。 NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。 pthread_mutex 互斥锁 dispatch_semaphore 信号量实现加锁 GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”。 OSSpinLock OSSpinLock 显示的效率最高（暂不建议使用） SVN与Git的区别 最核心的区别Git是分布式的，而Svn不是分布的。Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项目分支等操作，等网络再次连接上Push到Server端。 Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。 Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。 Git的内容的完整性要优于SVN： GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。 SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复制5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！ 版本库（repository)：SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ 分支（Branch）：在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开启无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。） 提交（Commit）：在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。 总结： SVN的特点是简单，只是需要一个放代码的地方时用是OK的。 Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。 iOS开发之使用Git的基本使用一、GitHub准备工作跳转我的GitHUb，并且创建一个仓库名字 二、项目准备工作 在你的代码目录下（此处以桌面为例）建一个新的目录（文件夹，此处为testGit） 打开终端，切换到上面的文件夹，使用 git init命令初始化 用Xcode创建一个iOS项目，该项目就放在刚刚新建的文件夹下 在Xcode里面选择菜单Source Control下的commit 三、关联GitHub和项目代码1、上传项目至git仓库 打开网站 https://help.github.com ，这个是GitHub的帮助网站，搜索ssh，选择红框的选项：Generating a new SSH key and adding it to the ssh-agent 打开之后里面有教大家如何产生SSH key，主要用到一个命令：ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;,写入终端获取密钥 新建一个终端，然后执行上面的命令，一直回车，直到看到如下的界面说明生成SSH key成功 此时在用户文件夹下会产生一个ssh的隐藏文件夹，cd切换到该ssh目录下，可以通过ls -a可以看到该文件下有两个重要文件id_rsa和id_rsa.pub，命令： cd ~ cd .ssh/ ls -a 在终端直接使用pbcopy &lt; id_rsa.pub命令复制一下密钥，此时密钥已经在剪贴板 重新打开一个GitHub网页，点击个人头像，打开Settings,选择左边的SSH and PGP keys，然后点击右侧的New SSH key，最后将密钥粘贴过去，添加SSH key 找到GitHub准备工作中让大家复制的指令，打开终端切换到项目文件夹，执行该命令:git remote add orgin https://github.com/mlj311/Test 打开Xcode选择菜单Source Control，点击的push按钮，然后输入自己的GitHub帐号和密码，等待上传完成 1.1、假如已经有github了，那就简单了： 1.1.1、创建一个新仓库”newProject“ 1.1.2、终端cd文件夹，输入指令：git init 1.1.3、git add . 1.1.4、git commit -m “XXX”; 1.1.5、关联仓库：git remote add origin https://github.com/XXX/newProject.git 1.1.6、git push -u origin master 2、对于复杂的系统，我们可能要开好几个分支来开发，那么怎样使用git合并分支呢？合并步骤： 2.1、进入要合并的分支（如开发分支合并到master，则进入master目录）git checkout mastergit pull 2.2、查看所有分支是否都pull下来了git branch -a 2.3、使用merge合并开发分支git merge 分支名 2.4、查看合并之后的状态git status 2.5、有冲突的话，解决冲突； 2.6、解决冲突之后，将冲突文件提交暂存区git add 冲突文件 2.7、提交merge之后的结果git commit 如果不是使用git commit -m “备注” ，那么git会自动将合并的结果作为备注，提交本地仓库； 2.8、本地仓库代码提交远程仓库git push git将分支合并到分支，将master合并到分支的操作步骤是一样的。]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零浅尝RN之道]]></title>
    <url>%2F2019%2F08%2F14%2F%E4%BB%8E%E9%9B%B6%E6%B5%85%E5%B0%9DRN%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[从零浅尝RN之道 1.为啥要做这个RN项目嘞？目前iOS开发就业形势还是很严峻的，而且现在又出现了“大前端”这个词语。那么这个“大前端”是什么嘞，我也去好好去度娘那边查询了一波。大前端是什么？简单来说，大前端就是所有前端的统称，比如Android、iOS、web、Watch等，最接近用户的那一层也就是UI层，然后将其统一起来，就是大前端。大前端最大的特点在于一次开发，同时适用于所有平台，开发者不用为一个APP需要做Android和iOS两种模式而担心。大前端是web统一的时代，利用web不仅能开发出网站，更可以开发手机端web应用和移动端应用程序。好啦，这乍一看，WEB端准备抢移动端饭碗了，想当初……呸呸呸，想什么当初什么，还不如自己去学习如何将移动端先把它吃下来。目前的话，有好多种跨平台方案可以尝试。跨平台方案，目前的主流跨平台方案：Cordova/phoneGap、React Native、Weex、微信小程序、PWA和Flutter等，根据其原理性，可以分为三大类。我所去涉及过的有React Native、微信小程序、Flutter，也就是搭个环境去初步看了一下，想去看看这些对于我来说哪个比较适合我，以及哪个目前市面上的公司运用的比较多。 H5+原生混合开发这种模式又称为Hybrid开发，现在很多App都用这种模式去开发，常见的有微信、淘宝、美团、爱奇艺等知名移动应用等。国内也有很多公司使用Hybrid模式去开发平台，供开发者使用，像Dcloud、AppCan、Inoic等，基本上都是参考Cordova衍生出的混合开发框架。 这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（ios）来加载，H5部分是可以随时改变而不用发版，这样就解决了动态化的需求，同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，我们称这种h5+原生的开发模式为混合开发。采用混合模式开发的APP我们称之为混合应用或Hybrid APP。 由于原生开发可以访问平台所有功能，而混合开发中，h5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。 混合应用的优点是动态内容是H5，使用web技术栈就可以开发，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，webview不堪重任。 JavaScript开发+原生渲染这类开源框架的代表主要是Facebook的React Native、阿里的Weex，当然也有未开源的美团的Picasso，以及最新推出的快应用。JavaScript开发+原生渲染的方式主要优点如下： 采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。原生渲染，性能相比H5提高很多。动态化较好，支持热更新。当然也有缺点如下： 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。JavaScript为脚本语言，执行时需要JIT，执行效率和AOT代码仍有差距。+由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。 React NativeReact Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 React Native的原理和React设计一致，React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。 JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用： 为JavaScript提供运行环境。是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。而RN中将虚拟DOM映射为原生控件的过程中分两步： 布局消息传递； 将虚拟DOM布局信息传递给原生原生根据布局信息通过对应的原生控件渲染控件树由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Nativ是Web开发技术栈，只需维护一份代码，即可在多个平台上使用。 WeexWeex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，React Native使用React.js作为开发框架，而Weex则使用Vue.js作为开发框架。Vue和React堪称前端领域最火的JavaScript框架，它们的易用性和功能性都非常强大，Weex在淘宝上也有广泛的应用。 快应用快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，目标直指微信小程序。它也是采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同： 快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。 自绘UI+原生通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下： 性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。不足之处： 动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。 FlutterFlutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加原生扩展。 Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎，值得一提的是，由于Android系统已经内置了Skia，所以Flutter在打包APK(Android应用安装包)时，不需要再将Skia打入APK中，但iOS系统并未内置Skia，所以构建iPA时，也必须将Skia一起打包，这也是为什么Flutter APP的Android安装包比iOS安装包小的主要原因。 但是Flutter也有不足之处，不支持动态下发代码和热更新。 PWA(Progress Web App)PWA不属于上述跨平台开发的某一种，它是一种理念，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，比如离线能力、本地缓存、和通知推送，兼具 Web App 和 Native App 的优点，看起来更像一个原生App。PWA完全使用前端技术栈，不过它需要手机和浏览器的支持，目前支持ServiceWorker和Google Play Service的Android手机，以及搭载11.3以上的iOS手机可以使用PWA。由于国内手机厂商和浏览器厂商的统一性问题，PWA在国内发展不是很好，但是在国外并没有这些问题。 大前端趋势总结一下哈，大前端不仅会成为移动开发与Web前端的发展趋势，也将会是未来的显示设备终端的开发技术趋势。大前端将做更多的终端开发、工程化等工作，而不仅仅只是开发Web页面。大前端工程师将能搞定所有端上的开发。与充满争议的全栈工程师相比，它更具可操作性。但同时对开发者而言，要会更多的技术栈，比如原生开发者要学习html、css、js等前端知识，前端开发人员也要学习Android或iOS的原生开发技术，然后了解一下常见的跨平台技术，只有这样才能更好的融入到大前端的这个大家庭中。 所以，选择一种跨平台的方案刻不容缓，不然就会消失在程序员的海洋里面咯，我太难了！刚好，目前公司做了个重构，全是新产品]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>reactnative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019iOS面试题出炉]]></title>
    <url>%2F2019%2F03%2F22%2F2019iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%87%BA%E7%82%89%2F</url>
    <content type="text"><![CDATA[2019面试题 1.swif与OC的区别 swift没有地址指针的概念 泛型 类型严谨对比OC的动态绑定 2.编译连接 id和instancetype的区别 instancetype只能返回值编译时判断真实类型，不符合发警告 特殊情况：关联类型返回方法如类方法alloc或者new开头实例方法中，以autorelease，init，retain，或self开头 3.synthesize &amp; dynamic1、通过@synthesize指令告诉编译器在编译期间产生getter/setter方法2、通过@dynamic指令，无法自己实现方法。有些存取是在运行时动态创建的，如在CoreData的NSManageObject类。 4.在项目开发中常用的工具有哪些 instrument beyondCompare git 5.UlTableView &amp; UlCollection UlCollectionView是iOS6新引进的API,用于展示集合视图，布局更加灵活，其用法类似于UITableView。 而UICollectionView、UlCollectionViewCell与UITableView、UITableViewCell在用法上有相似的也有不同的，下面是一些基本的使用方法：对UITableView，仅需要UITableViewDateSource，UITableViewDelegate这两个协议 使用UlCollectionView需要实现：UICollectionViewDataSource,UlCollectionViewDelegate,UlCollectionViewDelegateFlowLayout这三个协议. 这是因为UlCollectionViewDelegateFlowLayout实际上是UCollectionViewDelegate的一个子协议，它继承了UlCollectionViewDelegate,它的作用是提供一些定义UlCollectionView布局模式的函数 6.NSProxy &amp; NSObject NSObject协议组对所有的Object-C下的objects都生效。如果objects遵从该协议，就会被看作是first-class（一级类）。另外，遵从该协议的objects的retain、release、autorelease等方法也会服从objects的管理和在Foundation中定义的释放方法。一些容器中的对象也可以管理这些objects，比如说NSArray和NSDictionary定义的对象，Cocoa的根类也该遵循该协议，所以所有集成NSObject的objects都有遵循该协议的特性。 NSProxy：NSProxy是一个虚基类,它为一些表现像其他对象替身或者并不存在的对象定义一套API。一般发送给代理的消息被转发给一个真实的对象或者代理本身load（或者将本身转换成）一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy初始化。 7.Object &amp; Swift Obejective-C复杂的语法，更加简单易用、有未来，让许多开发者心动不已. 苹果宣称Swift的特点是:快速、现代、安全、互动，而且明显优于Objective-C语言可以使用现有的Cocoa和Cocoa Touch框架，Swift取消了Objective C的指针及其他不安全访问的使用 舍弃Objective C早期应用Smalltalk的语法，全面改为句点表示法提供了类似Java的名字空间(namespace)、泛型(generic)、运算对象重载(operator overloading) Swift 被简单的形容为“没有C的Objective-C” (Objective- C without theC)为苹果开发工具带来了Xcode-Playgrounds功能，该功能提供强大的互动效果，能让Swift源代码在撰写过程中实时显示出其运行结果; 基于C和Objective-C,而却没有C的一些兼容约束; 采用了安全的编程模式;界面基于Cocoa和Cocoa Touch框架;保留Smaltalk的动态特性 8.传值通知&amp;推送通知(本地&amp;远程)传值通知:类似通知，代理，Block实现值得传递 推送通知:推送到用户手机对应的App上(主要是不再前台的情况)本地通知。 local notification 用于基于时间行为的通知，比如有关日历或者todo列表的应用。另外，应用如果子啊后台执行，iOS允许它在受限的时间内运行，它也会发现本地通知有用。比如，一个应用，在后台运行，向应用的服务器端获取消息，当消息到达时，比如下载更新版本的消息，通知本地通知机制通知用户。 本地通知是UILocalNotification的实例，主要有三类属性： scheduled time，时间周期，用来指定iOS系统发送通知的8期和时间； notification type，通知类型，包括警告信息、动作按钮的标题、应用图标上的badge]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初见Python]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%88%9D%E8%A7%81Python%2F</url>
    <content type="text"><![CDATA[前言Python是一种计算机程序设计语言。是一种动态的、面向对象的脚本语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 Python，怎么会出现在开发iOS的博客中？不出两种情况：1、iOS开发转Python；2、技多不压身嘛。我属于后者，但是偏偏那么多语言在，却选择了Python，不好意思，我也不知道，就先认识认识Python嘛！ 认识 PythonPython 简介Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 发展历史Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。 Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。 像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。 现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。 Python 特点 易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。 易于阅读：Python代码定义的更清晰。 易于维护：Python的成功在于它的源代码是相当容易维护的。 一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。 互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。 可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。 可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。 数据库：Python提供所有主要的商业数据库的接口。 GUI编程：Python支持GUI可以创建和移植到许多系统调用。 可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。 看来，Python的特点很多嘛，如此强大的一门语言，比如国外YouTube、Google，国内知乎，网易，腾讯，搜狐，金山，豆瓣都属于用Python比较知名的。 我看了看这些特点，吸引我的应该是第一点吧，啊哈哈哈哈哈☺️ 使用 Python我之所以学习Python主要也是一位同事提起，对于我一些个人技能提高上的建议吧，所以我也听从了他的建议，并向他询问了关于使用什么工具来写Python，Visual Studio Code 。 VS CodeVS Code，一百度才想起之前好像在学校中使用过，可惜全部还给老师了，隐约中感觉我之前使用的那个VS Code要low很多。算了，反正全忘记了，这认识认识这个VS Code吧！ VS Code还是很强大的，各种热门扩展，启用其他语言，主题，调试器，命令等。VS Code不断发展的社区分享了他们的秘诀，改善工作流程。 这边的话主要是VSCode python的配置，我也没必要去上面再Control C Control V的，因为实在太多了，懒，也没必要，况且我也还没全部看完呢。就一步一步跟着这个教程来做，其中也会碰到一些各式各样的问题哈，仔细看教程，百度搜索就可以解决哒。 先写这么多，未完待续哦]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发经验总结]]></title>
    <url>%2F2018%2F12%2F12%2FiOS%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS开发经验总结，更新中… iPhone Size手机型号屏幕尺寸iPhone 4/4s320 480iPhone 6/6s 7 8375 667iPhone 6plus/6s plus/7 plus/8 plus414 736iPhone X/Xs375 812iPhone XR276 598iPhone Xs Max414 896 给navigation Bar 设置 title 颜色123UIColor *whiteColor = [UIColor whiteColor];NSDictionary *dic = [NSDictionary dictionaryWithObject:whiteColor forKey:NSForegroundColorAttributeName];[self.navigationController.navigationBar setTitleTextAttributes:dic]; 如何把一个CGPoint存入数组里123456CGPoint itemSprite1position = CGPointMake(100, 200);NSMutableArray * array = [[NSMutableArray alloc] initWithObjects:NSStringFromCGPoint(itemSprite1position),nil]; // 从数组中取值的过程是这样的： CGPoint point = CGPointFromString([array objectAtIndex:0]); NSLog(@&quot;point is %@.&quot;, NSStringFromCGPoint(point)); 可以用NSValue进行基础数据的保存，用这个方法更加清晰明确。 12345678CGPoint itemSprite1position = CGPointMake(100, 200);NSValue *originValue = [NSValue valueWithCGPoint:itemSprite1position];NSMutableArray * array = [[NSMutableArray alloc] initWithObjects:originValue, nil];// 从数组中取值的过程是这样的：NSValue *currentValue = [array objectAtIndex:0];CGPoint point = [currentValue CGPointValue];NSLog(@&quot;point is %@.&quot;, NSStringFromCGPoint(point)); 现在Xcode7后OC支持泛型了，可以用*> *array```来保存。12## UIColor 获取 RGB 值 UIColor color = [UIColor colorWithRed:0.0 green:0.0 blue:1.0 alpha:1.0];const CGFloat components = CGColorGetComponents(color.CGColor);NSLog(@”Red: %f”, components[0]);NSLog(@”Green: %f”, components[1]);NSLog(@”Blue: %f”, components[2]);NSLog(@”Alpha: %f”, components[3]);12## 修改textField的placeholder的字体颜色、大小 self.textField.placeholder = @”username is in here!”;[self.textField setValue:[UIColor redColor] forKeyPath:@”_placeholderLabel.textColor”];[self.textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@”_placeholderLabel.font”];12推荐 使用attributedString进行设置. NSString string = @”美丽新世界”; NSMutableAttributedString attributedString = [[NSMutableAttributedString alloc] initWithString:string]; [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, [string length])]; [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:16] range:NSMakeRange(0, [string length])]; self.textField.attributedPlaceholder = attributedString; 12## 两点之间的距离 static inline CGFloat CGPointDistanceBetweenTwoPoints(CGPoint point1, CGPoint point2) { CGFloat dx = point2.x - point1.x; CGFloat dy = point2.y - point1.y; return sqrt(dxdx + dydy);}1234## iOS开发－关闭/收起键盘方法总结1.点击Return按扭时收起键盘 (BOOL)textFieldShouldReturn:(UITextField *)textField{ return [textField resignFirstResponder];}122.点击背景View收起键盘 [self.view endEditing:YES];123.你可以在任何地方加上这句话，可以用来统一收起键盘 [[[UIApplication sharedApplication] keyWindow] endEditing:YES];12345678## 在使用 ImagesQA.xcassets 时需要注意将图片直接拖入image到ImagesQA.xcassets中时，图片的名字会保留。 这个时候如果图片的名字过长，那么这个名字会存入到ImagesQA.xcassets中，名字过长会引起SourceTree判断异常。## UIPickerView 判断开始选择到选择结束开始选择的，需要在继承UiPickerView，创建一个子类，在子类中重载 (UIView)hitTest:(CGPoint)point withEvent:(UIEvent)event 12当```[super hitTest:point withEvent:event]```返回不是nil的时候，说明是点击中UIPickerView中了。 结束选择的， 实现UIPickerView的delegate方法 (void)pickerView:(UIPickerView*)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component 1234当调用这个方法的时候，说明选择已经结束了。## iOS模拟器 键盘事件 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide) name:UIKeyboardWillHideNotification object:nil];1234进行键盘事件的获取。那么在此情景下将不会调用```- (void)keyboardWillHide. ```因为没有键盘的隐藏和显示。## 线程中更新 UILabel的text [self.label1 performSelectorOnMainThread:@selector(setText:) withObject:textDisplay waitUntilDone:YES];``` label1 为UILabel，当在子线程中，需要进行text的更新的时候，可以使用这个方法来更新。 其他的UIView 也都是一样的。 使用UIScrollViewKeyboardDismissMode实现了Message app的行为]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS与Android历史版本对比]]></title>
    <url>%2F2018%2F12%2F10%2FiOS%E4%B8%8EAndroid%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[iOS与Android历史版本对比 Symbian在讨论Android和ios前，Symbian是一个无论如何也不能绕开的话题。 众所周知，在老手机巨头诺基亚大行其道的时代，Symbian虽然说不上是独领风骚，那也是人尽皆知，Symbian系统是塞班公司为手机而设计的操作系统。众所周知，在iOS只提供给自家的产品，Android乘虚而入。在iOS和Android占据了绝大多数的市场份额后，塞班无奈沦陷，后在独木难支的挣扎下最终退出市场。 2007年06月，iPhone OS 1乔布斯在2007年推出了首款iPhone，可以说最核心的智能手机应用在这个版本已经有了，包括地图、浏览器、itunes、全屏幕触摸操作，这也可以理解当第一代iphone出现时带给所有人的震撼。 2008年07月，iPhone OS 2iPhone OS 2最重大的改变是开放了AppStore，可以开发和使用第三方应用了，这几乎是整个移动互联网生态的基石。 2008年09月，Android1.0iOS2.0之后2个月，Android横空出世，全球第一台Android设备是HTC Dream。Android在1.0时基本也把完整的智能手机体验带给了广大用户，当然也包括了AndroidMarket。 2008年12月2日，塞班公司被诺基亚收购塞班公司被诺基亚收购。 2009年04月，Android1.5（Cupcake 纸杯蛋糕） 增加了虚拟键盘的支持，之前只支持实体键盘 支持Widget功能，可以在桌面创建音乐播放器、文件夹快捷方式等功能 其他优化 2009年06月，iPhone OS 3 / iOS 3 第三个大版本开始被称为“iPhone OS 3”，而在宣布将出现“更大的iPhone”时，它被命名为“iOS 3”。 新版本的 iOS 带来了许多新功能，比如复制粘贴、著名的 Spotlight 搜索和语音控制。 除此之外，App还出现了备受争议的新外观：拟物设计（skeuomorphism）。 2009年09月，Android1.6（Donut甜甜圈） 支持CDMA网络 其他优化 2010年04月，iOS3.2推出iPad，主要添加了对iPad的支持 2010年05月，Android 2.2（Froyo冻酸奶） 支持将软件安装至存储卡，这是一个相当重要的功能，从此再也不用担心手机内存卡装不下app了 引入JIT，即时编译技术（Just-in-time Compilation，JIT），是一种通过在运行时将字节码翻译为机器码，从而改善字节码性能的技术。JIT技术可以部分提高Android的程序执行效率，但对图形渲染、线程调度、I/O等都无明显的改善，所以这种技术的引入远没有官方宣传的那样得到几倍的提升。 浏览器采用V8 JavaScript 引擎，将 JavaScript 的性能提升了 2 到 3 倍。 2010年09月，iOS 4显著的变化是支持了多任务，尽管并不同桌面系统中真正的多任务处理，但这是苹果理解的在移动设备上用户所需要的多任务。随着多任务支持，双击home键的效用由原来的截屏操作，变为显示最近运行的应用。 2010年12月，Android2.3（Gingerbread姜饼） Gaming Api，将 Android 游戏推到了新的高度 NFC（近场通讯） 电池管理：能够监测设备使用电量的具体方式以及设备方方面面（屏幕亮度、正在运行的应用等）消耗的电量，因而可帮助您充分延长电池续航时间。 这是一个相当成熟的系统，导致一个很长的时间内国产机一直保持在这个系统版本上。 2011年02月，Android 3.0（Honeycomb蜂巢）专为Android平板设计的操作系统，但却是个短命的版本，因为他不兼容phone 2011年04月，Android 4.0（Ice Cream Sandwich冰淇淋三明治） 统一了手机和平板操作系统 基于linux3.0.1内核 性能优化 2011年10月，iOS 5 iOS 5中的许多新功能不仅关系到 iOS，还影响到苹果的整个商业生态系统。就拿iCloud来说，苹果可以通过它来连接自家的各种设备。 iOS 5还带来了许多与“信息交流”有关的改进：除了新的 iMessage 和通知中心外，该系统对Twitter做了更深入的整合。 重点功能是增加了siri，虽然当时很惊艳，但现在基本是个鸡肋功能。 2011年12月21日，诺基亚官方宣布放弃塞班系统（Symbian）品牌诺基亚官方宣布放弃塞班系统（Symbian）品牌。 2012年5月27日，诺基亚彻底放弃开发塞班系统诺基亚彻底放弃开发塞班系统，但服务将一直持续到2016年。 2012年06月，Android 4.1/4.2/4.3（JellyBean 果冻豆） GoogleNow 类似siri 性能以及稳定性的提升 2012年09月，iOS 6 无明显亮点，槽点是把之前一直使用的GoogleMap换成了苹果自己的Map。 因为YouTube和Google地图不再预装，使得 iOS 6成为一个很特别的更新。苹果不顾自己对谷歌的依赖，引入了自己的地图服务（注：然而当时因为该服务很差劲，被骂的很惨）。 此外，苹果的 iCloud 服务得到了更广泛的使用：新的 iOS 终于允许共享照片流了。与Facebook和新Passbook更深入的整合，则是其他一些明显的补充。 2013年1月24日，诺基亚宣布，今后将不再发布塞班系统的手机诺基亚宣布，今后将不再发布塞班系统的手机，一位着塞班这个只能手机操作系统，在长达14年的历史之后，终于迎来了谢幕。 2013年09月，iOS 7 UI从拟物化转变为扁平化 Touch ID 允许通过指纹识别来解锁设备 控制中心跟着 Android 也用上了快速设置切换 AirDrop 终于可以轻松地将文件从一个苹果设备传输到另一个 2013年10月，Android 4.4（奇巧Kitkat）各种功能的优化，虽然没有明显的亮点，但稳定性较高，很长一段时间国内Android系统的主流版本，甚至到4年后的今天，仍然占有了约5%的市场 2014年1月1日，诺基亚正式停止应用更新诺基亚正式停止了Nokia Store应用商店内对塞班应用更新，也禁止开发人员发布新应用。 2014年09月，iOS 8 再一次的，苹果将其桌面和移动平台更紧密地结合在一起：这次主打“连续性”概念，不仅是iPhone，在Mac上也可以阅读和编辑 iMessages，或者接听电话。 总而言之，iOS 8主要集中在使平台更加可扩展和开放：第三方App现在可以添加自己的通知中心小部件，相对更容易地访问照片库。 随着 iOS 8发布，苹果也进入了“新”市场：HealthKit和 HomeKit 可能为其打开未来的市场。 2014年10月，Android 5.0（棒棒糖Lollipop） 采用全新Material Design界面 采用ART虚拟机，全面由 Dalvik 虚拟机转用 [Android RunTime]（ART）编译虚拟机。官方宣称新的虚拟机相较于旧虚拟机，性能可提升四倍。 2015年09月，iOS 9 主动性（Proactivity）是 iOS 9 中的核心话题：iOS 现在更加理解像时间或位置等的上下文信息。 它会尝试更好地预测用户需求，给出合适的App，网站，音乐和新闻资讯等建议。 然而，由于没有任何大的新“旗舰”性功能，iOS 9 主要集中在性能和稳定性上的改进。 2015年10月，Android 6.0（棉花糖Marshmallow） 全新的权限机制，在原有AndroidManifest.xml声明权限的基础上，新增了运行时权限动态检测，以下权限都需要在运行时判断，包括：身体传感器、日历、摄像头、通讯录、地理位置、麦克风、电话、短信、存储空间。 增加Android Pay付费功能 2016年08月，Android 7.0（牛轧糖Nougat） 支持多视窗 通知增强功能 配置文件指导的 JIT/AOT 编译，JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。 2016年09月，iOS 10 iOS 10 将 iMessage 提升到不仅仅是一个简单的应用程序：贴纸和单独的 “App Store” 将其转变为一个全面的平台，并且它向第三方开发者开放。 允许删除苹果默认应用 iOS 向开发者的开放，Siri 现在可以与非苹果的应用程序进行交互了，而新的“家庭”App 可以让你控制智能家居。 另一个明显的变化是关于“通知”的，它现在可以直接显示照片和视频。 2017年08月，Android8.0（奥利奥Oreo） TensorFlow Lite，TensorFlow Lite是谷歌机器学习工具TensorFlow的精简版，新工具可帮助低功耗设备跟上当今高强度任务处理，利用新的神经网络API帮助底层芯片加速数据处理。 智能文本选择，智能文本选择（Smart Text Selection）是使用谷歌的机器学习来检测何时选择地址或电话号码，然后自动将其应用于相应的应用程序的功能 自动填写，对于用户设备上最常用的应用，Android O将会帮助用户进行快速登录，而不用每次都填写账户名和密码。 Google Play Protect，可以视为安卓应用的病毒扫描程序 系统/应用启动程序加速，谷歌表示，在Android O上， Pixel设备的启动几乎只需要原来一半的时间。 2017年09月，iOS 11 强化了iMessages，主要是加入了对Apple Pay转账的支持 增加了对AR增强现实的支持，为开发者提供ARKit 优化了相机的功能 控制中心支持自定义 2018年9月，iOS 12 性能大大提升，俗称老机器的福音 FaceTime 通话新增表情滤镜等 信息，主要是拟我表情 屏幕使用时间 通知分组 增强现实 可以看出，从一开始两个平台的高歌猛进，版本频发（特别是Android系统，当初的版本真的是满天飞，记得还有个中移动定制的android版本），到现在基本上是一年一个版本。两个系统都从野蛮成长阶段过度到了平稳发展的阶段。 同时两个平台也显示出了高度的同质化，从拍照、音乐、App市场、地图之类的基本功能，到语音助手（siri、now）、支付的高阶功能，再到现如今的AI、AR等，两个系统虽然你追我赶，但基本还是保持了步调的一致。随着Android系统性能的不断优化，如今的Android高端机至少在系统层面已经不差iOS了。]]></content>
      <categories>
        <category>history</category>
      </categories>
      <tags>
        <tag>iOS&amp;Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题转载]]></title>
    <url>%2F2018%2F11%2F27%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[iOS面试题 基础篇Objective-C的类可以多重继承么?可以采用多个协议么?不可以多重继承,可以采用多个协议. objc使用什么机制管理对象内存？1、手动引用计数2、自动引用计数，现在通常使用自动引用计数 #import 跟#include 又什么区别，@class呢, ＃import&lt;&gt; 跟 #import””又什么区别？ #import是OC导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import只会导入一次，不会重复导入，相当于#include和#pragma once；@class告诉编译器某个类的声明，当执行时，才会去查看类的实现文件，可以解决头文件的相互包含；＃import&lt;&gt;是包含系统的头文件，#import””是包含用户的头文件。 描述一下iOS SDK中如何实现MVC的开发模式 MVC是模型、视图和控制开发模式，对于iOS SDK所有view都是视图层的，它应该都独立于模型层，由控制层来控制。所有的用户数据都是模型层，它应该独立于视图层。所有的ViewController都是控制层，它负责控制视图，访问模型数据。 浅复制和深复制的区别？浅复制：只是复制了指向对象的指针，而不复制对象本身。深复制：复制引用对象本身。 意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。 category是什么? 扩展一个类的方式用继承好还是类目好? 为什么?category是类目，当然类目好，因为继承要满足A is a B的关系，而类目只需要满足A has a B的关系,局限性更小，你不用定义子类就能扩展一个类的功能，还能将类的定义分开放在不同的源文件里,用category去重写类的方法,仅对本category有效,不会影响到其他类与原有类的关系。 延展是什么? 作用是什么?延展(extension):在自己类的实现文件中添加类目来声明私有方法。 解释一下懒汉模式?懒汉模式，只有使用的时候才会去初始化。也可以理解成延时加载。我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。一个延时载，避免内存过高，一个异步加载，避免线程堵塞。 #进阶篇 @property中有哪些属性关键字？属性可以拥有的特质分为四类: 1、原子性 – nonatomic：在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 2、读/写权限 —- readwrite(读写)、readonly (只读) 3、内存管理语义 – assign、strong、 weak、copy 4、方法名 —- getter= 、setter= 你经常使用一些第三方库有哪些?1.AFNetworking 2.SDWebImage 3.FMDB (没怎么用，得学习) 4.JSONKit 5.MJRefresh 6.MJExtension（需要再复习） 7.Masonry 8.友盟，shareSDK等三方库。 你经常用的设计模式有哪些？1.MVC 2.代理模式 (Delegate) 3.观察者模式 (NSNotification/KVO) 4.单例模式 (需要多使用) 5.工厂模式 – 简单工厂，工厂方法， 抽象工厂三种设计模式(需要多使用) 本地存储有哪些方式？1.属性列表（NSUserDefault 或 plist） 2.对象归档 （NSKeyedArchiver） 3.SQLite 4.CoreData weak属性需要在dealloc中置nil么？不需要，在ARC环境无论是强指针还是弱指针都无需在deallco设置为nil,ARC会自动帮我们处理。 @synthesize和@dynamic分别有什么作用？1、@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var; 2、@synthesize:如果你没有手动实现setter方法和getter方法，编译器自动生成setter和getter方法 3、@dynamic:不会生成setter和getter方法，用户自己实现 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？1、因为父类指针可以指向子类对象，使用copy的目的是为了让本对象的属性不受外界影响，使用copy无论给我传入一个可变对象还是不可变对象，我本身持有一个不可变对象的副本 2、如果使用strong，那么这个属性有可能指向一个可变对象，如果这个可变对象的属性被外部修改了，那么会影响该属性 什么时候会报unrecognized selector的异常？当该对象上某个方法,而该对象上没有实现这个方法的时候 使用block时什么情况会发生引用循环，如何解决？1、只要是一个对象对该block进行了强引用，,在block内部有直接使用到该对象。 2、解决方案：__weak id weakSelf = self; 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？不需要考虑，因为官方文档中没有告诉我们要注意发生强引用,所以推测系统控件一般没有对这些block进行强引用,所以我们可以不用考虑循环强引用的问题 GCD的队列（dispatch_queue_t）分哪两种类型？串行队列和并行队列 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）总体上说: 使用 dispatch group，然后 wait forever 等待完成， 或者采取 group notify 来通知回调。 12345678dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 合并图片&#125;) 以下代码运行结果如何？123456789- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@&quot;1&quot;); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;2&quot;); &#125;); NSLog(@&quot;3&quot;);&#125; 只输出1，然后主线程锁死 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？都可以–可以根据kvc的底部实现来解释 IBOutlet连出来的视图属性为什么可以被设置成weak?因为视图已经对它有一个强引用了 你单例怎么理解怎么用的? —- ※Singleton Pattern单例设计模式，通过单例模式可以保证系统中只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制节约系统资源。如果希望在系统的某个类的对象只能存在一个，单例模式是最好的解决方案。类只能有一个实例，而且必须从一个为人熟知的访问点进行访问，比如工厂方法。这个唯一的实例只能通过子类化进行扩展，而且扩展对象不会破坏客户端代码。例如，UIApplication的sharedApplication方法，任何时候都会返回一个当前应用程序的UIApplication实例。 lldb（gdb）常用的调试命令？最常用就是：po 对象 什么是谓词？谓词是通过NSPredicate，是通过给定的逻辑条件，完成对数据的筛选 +(void)load; +(void)initialize; 的区别？+(void)load：在程序执行后运行 +(void)initialize：在类的方法第一次被调时执行 什么是KVC，什么是KVO？KCV：键 - 值编码是对象的一种间接访问属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。 KVO： 键 - 值观察机制，提供了观察某一属性变化的方法，极大的简化了代码。 什么时候用delegate，什么时候用Notification？delegate是一对一，并且接受者可以返回值给发送者（反向传值）；Notification是一对一也可以一对多，接受者无法可以返回值给发送者。所以，delegate用于发送者希望受到接受者的某个功能的反馈值。notification用于通知多个object某个事件 block和weak区别？1、__block不管是在ARC还是MRC的模式下都可以使用，可以修饰对象，也可以修饰数据类型 2、weak只能在ARC模式下使用，只能修饰对象不能修饰数据类型 3、block对象可以在block被重新赋值，但weak不行 frame和bounds有什么不同？frame：该view在父视图坐标的位置和大小（参照点是父亲的坐标系统）；bounds：该view本身坐标的位置和大小（参照点是本身坐标系统） UIView和CALayer有什么不同？两者最大的区别是图层不会直接渲染到屏幕上，UIView是iOS系统中界面的元素，所有的界面元素都是继承自它。它本身完全是由CoreAnimation来实现。它真正绘图部分，是由一个CALayer类来管理。UIView本身更像一个CAlayer的管理器。一个UIView上可以有N个CALayer，每个layer显示一种东西，增强UIView的展现能力。 TCP和UDP的区别？TCP（传输控制协议）：提供面向连接的、可靠地点对点的通信 UDP（用户数据报协议）：提供非面向连接的、不可靠地点对多点的通信 socket连接与http连接Socket：长链接，即客户端一旦与服务器建立起链接，便不会主动断掉 http：短链接，即客户端向服务端发起一次请求，链接立即断开 HTTP 的post与get区别与联系，实践中如何选择它们?1、get是服务器上获取数据，post是向服务器发送数据 2、在客户端，get方式，在通过URL提交数据，数据可以在URL中可以看到；post方式，数据放置在HTML HEADER内提交 3、对于get方式，服务器用Request.QueryString获取变量的值；post方式，服务器用Request.From获取提交的数据 4、Get方式提交数据最多1024字节，post则没有限制 5、安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 检查内存管理问题的方式有哪些1、点击Xcode顶部菜单栏Product–Analyze。这种方法可以查看内存泄露，变量未初始化，变量定义后没有被使用到 2、使用Instrument工具检查。点击Xcode顶部菜单中的Product Profile，弹出一个界面，选择左侧的Memory后，再选右侧的Leaks。 3、人工检查 谈安卓与苹果的优缺点苹果系统优点是左右流畅，软件多，界面华丽，图标统一，很美观；缺点是系统封闭，不允许用户过多的个性化设置，而且只能在苹果手机上用。安卓系统优点是开放，可以自己扩展的东西很多，支持的硬件也多，各个价位的手机都有；缺点就是软件太杂乱，兼容性有问题，图标混乱不美观。iOS的确比android流畅，这仅仅体现在较大软件切换时，其他差不多流畅，iOS并不能做到完全后台，如果它完全后台估计也不会比安卓流畅多少。反之，如果安卓只是注重单个运行，流畅度也会大大提升，iOS系统更新没有android那么频繁，爱体验的人会选安卓，那些怕烦的会选iOS。iOS的硬件需求选不及android，以至于android机会相对iOS较热，较费电额。 大神篇运行时你是怎么理解的?ObjC Runtime其实是一个Runtime库，基本使用C和汇编的，这个库是得C语言有了面向对象的能力。这个库的事情就是加载类的信息，进行方法的分发和转发之类的。OC是一种runtime（运行时）的语言，也就是说，它会尽可能的把代码执行的决策从编译和链接的时候，推迟到运行时。这给程序员写代码带来很大的灵活性，比如说你可以把你消息转发给你想要的对象，或者可以随意交换一个方法的实现之类的。这就要求runtime能检测到一个对象是否能对一个方法的响应，然后再把这个方法分发到对应的对象中去。 @protocol 和 category 中如何使用 @property1、在@protocol只生成setter和getter方法声明，我们使用属性的目的，是希望遵守我协议的对象实现该属性 2、category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给category增加属性的实现，需要借助运行时的两个函数① objc_setAssociatedObject ②objc_getAssociatedObject runtime如何通过selector找到对应的IMP地址？每一个对象都有一个方法列表，方法列表中记录着方法名称，方法实现以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到相应的方法实现 一个objc对象如何进行内存布局？1、所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中 2、每个对象内部都有一个isa指针，指向它的类对象，类对象中存放着本对象 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象） 成员变量的列表 属性列表 它内部也有一个isa指针指向元对象（meta class），元对象内部存放着类方法列表，类对象内部存放着一个superclass的指针，指向它的父对象 本篇文章转载自一个低调的iOS开发]]></content>
      <categories>
        <category>reprint</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题大杂烩]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%9D%82%E7%83%A9%2F</url>
    <content type="text"><![CDATA[面试题大杂烩 1.iOS开发之事件响应链：Appdelgate —-&gt; UIApplication —-&gt; UIWindow —-&gt; UIViewController —-&gt; UIView —-&gt; UIButton 2.UITableView 的两种样式Plain和Group的区别：Plain：tableview加载出来没有中间间距和头部间距 Group：tableview加载出来有中间间距和头部间距 一般默认并且常用：Plain 3.KVC中ValueForKey与ValueForKeyPath的区别：在一般修改一个对象的属性时，ValueForKey与ValueForKeyPath没有什么区别，都可以改变属性值 强大之处：假如Person这个类中有dog有bone ValueForKeyPath可以利用点语法，深层次的去寻找我们所需的属性 例如1： 12345678NSDictionary *dic1 = @&#123;@&quot;city&quot;:@&quot;北京&quot;,@&quot;count&quot;:@&quot;22&quot;&#125;;NSDictionary *dic2 = @&#123;@&quot;city&quot;:@&quot;上海&quot;,@&quot;count&quot;:@&quot;18&quot;&#125;;NSDictionary *dic3 = @&#123;@&quot;city&quot;:@&quot;深圳&quot;,@&quot;count&quot;:@&quot;17&quot;&#125;; NSArray *arr = @[dic1,dic2,dic3]; NSLog(@&quot;city:%@&quot;,[arr valueForKeyPath:@&quot;city&quot;]);NSLog(@&quot;count:%@&quot;,[arr valueForKeyPath:@&quot;count&quot;]); 输出结果: 12345678910112016-08-03 15:07:05.276 ValueForKeyPath使用[5181:192059] city:( &quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;)2016-08-03 15:07:05.276 ValueForKeyPath使用[5181:192059] count:( 22, 22, 18, 17) 例如2： 123456789Student *student1 = [[Student alloc] init];student1.name = @&quot;小红&quot;;student1.info = @&#123;@&quot;phone&quot;:@&quot;13102212345&quot;,@&quot;mail&quot;:@&quot;xiaohong@qq.com&quot;&#125;; School *school = [[School alloc] init];school.student = student1; NSLog(@&quot;%@&quot;,[school valueForKeyPath:@&quot;student.name&quot;]);NSLog(@&quot;%@&quot;,[school valueForKeyPath:@&quot;student.info.phone&quot;]); 输出结果： 1232016-08-03 15:21:38.258 ValueForKeyPath使用[5261:202278] 小红2016-08-03 15:21:38.258 ValueForKeyPath使用[5261:202278] 131022123452016-08-03 15:21:38.259 ValueForKeyPath使用[5261:202278] xiaohong@qq.com 4.iOS10+与iOS10之前，远程推送有何区别？1.title,subtitle,body可用新版Server SDK发送，客户端不用修改；2.添加图片；3.利用Server SDK设置mutable-content字段，并在extra中增加字段imageUrl。 5.Block为什么加__block就可以改变变量？Block不允许修改外部变量的值，外部变量指的是栈中指针的内存地址。__block所起到的作用就是只要观察到变量被block所持有，就可以将“外部变量”在栈中的内存地址改到堆中。进而在block内部也可以修改外部变量。 6.GCD多线程：主队列（main）和全区队列（global）主队列：每个应用程序对应唯一一个主队列，直接get即可，使用主队列更新UIPS：主队列同步，会锁死全局队列：是系统的，直接GET使用，与并行队列类似，无法确认操作所在队列（调试时） 7.UITableView优化：1、正确使用UITableView的重用机制2、提前计算好cell的高度与布局3、避免阻塞主线程4、按需加载5、尽可能重用开销较大的对象6、尽可能减少计算复杂度7、不要动态增加或者移除子控件学会使用调试工具异步绘制 8.使用KVO的注意事项：1、addObserver在不需要监听的时候，及时remover，否则被监听对象释放后，再出发监听器就会崩溃2、addObserver和removeObserver方法要一一对应。不要重复添加，也不要视图删除没添加的监听;重复监听:在被监听对象属性改变时，会多次调用监听方法，视图删除没有添加过的监听器会引起崩溃。 9.KVO实现原理：1、KVO是基于runtime机制实现的2、当某个类的属性对象第一次被观察时，系统就会在运行期动态得创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。派生类在被重写的setter方法内实现真正的通知机制3、如果原类为person，那么生成的派生类名为：NSKVONotification_Person4、每个类对象中都有一个isa指针指向当前类，当一个对象的第一次被观察，那么系统偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法5、键值观察通知依赖于NSObject的两个方法：willChangeValueForKey和didChangeValueForKey，在一个被观察属性发生改变之前，willChangeValueForKey一定被调用，这就会记录旧的值。而当改变发生后，didChangeValueForKey会被调用，继而observerForKey：ofObject：change：context也会被调用 10.UIViewController与UIView生命周期UIViewController：viewDidload –&gt; viewWillAppear –&gt; viewDidLayoutSubviews – &gt; ViewWillDisappear –&gt; viewDidDisappear –&gt; dealloc UIView: init –&gt; layoutSubviews –&gt; dealloc 11.重现GCD死锁：（主线程在同步队列中）123dispatch_sync(dispatch_get_main queue ^()&#123;//code&#125;); 12.如何理解MVC设计模式和MVVM设计模式MVC：一种架构模式，M:Model V:View C:ControllerModel负责存储，定义操作数据View：用来展示给用户，和用户交互Controller：是model和view协调者，C将M中的数据取过来给V用。C可以直接与V、M通信，而V不能与C直接通信。V与C通信需要用代理协议方式，当有数据更新，M要与C进行通信这是需要Notification和KVO。M、V无法通信。 MVVM：Model–View–ViewModelViewModel层，是View与Model的粘合剂，放置用户验证逻辑，视图显示逻辑，发起网络请求与其他各种代码最佳位置，将ViewCOntroller层的业务逻辑与页面逻辑剥离放入ViewModel层 13.为什么说Object-C是一门动态语言Object-C类的类型和数据变量的类型都是在运行时确定，而不是在编译时确定。运行时（runtime）特性：可动态添加方法或替换方法 14.MVC、MVVM、MVP讲一下？MVC：简单来说，逻辑、视图、数据进行分层，实现解耦 MVVM：Model-View-ViewModel模式简称。由于视图、视图模型、模型三大部分组成，比MVC更能让控制器释放臃肿，将一部分逻辑和数据的处理等操作从控制器中搬运到ViewModelMVVM特点：1、低耦合。View可以独立于Model的变化和修改一个ViewModel可绑定多个不同View。View变化时Model可以不变，Model变化时View可以不变。2、可重用性。可将视图逻辑放入ViewModel，让很多View重写这段试图逻辑。3、独立开发。开发可专注业务逻辑和数据开发，设计可以专注界面设计。4、可测试性。可以针对ViewModel对界面进行测试。 MVP：Model–View–Present。模型、视图、Present。Present作为View和Model的中间人，从Model层获取数据传给View，使View和Model没有耦合。优势：使Model和View没有耦合，使Model更具有复用性。 15.为什么代理要用weak修饰?代理的delegate与dataSource什么区别？block和代理区别？代理用weak修饰。1、使用weak修饰防止循环使用。2、当使用weak修饰的属性，当对象释放时，系统对属性赋值为nil，OC对nil对象发送消息也就是调用方法，不会carsh。 delegate：传递事件，代理可以让A通知B，A变化时，前提B遵循A的代理，并实现A的代理方法。 dataSource：传递数据，对象A声明它所需数据，当我们创建A对象时，我们实现数据源，告诉A它所需的数据。例如：TableView的数据源方法告诉它需要几组Cell，每组几行，每个Cell实现什么 代理与Block区别：相同点：代理与Block大多是我们可以用来做倒叙传值。但得注意避免循环引用；不同点：代理使用weak修饰，代理必须声明方法。调用代理时判断是否实现；Block使用copy修饰，Block保存一段代码，（一个函数）并且可以自动捕捉自动变量，若想改变，必须使用__block修饰 16.属性的实质是什么？包括哪几个部分？属性默认关键字有哪些？@dynamic和@synthesize用来做什么？属性是描述类的特征。也就是具备什么特性。三个部分，带下划线的成员变量，getter和setter方法。默认关键词：readwriter、assgin、atomic，是针对基本类型（NSInteger、Bool、NSUInteger、int等）针对引用类型，默认：strong、readwriter、atomic，例如：NSString、NSArray、NSDictionary等@dynamic：修饰属性，其getter和setter方法编译器不会自动帮你去生成，必须自己实现。@synthesize：修饰属性，其getter和setter方法编译器自动帮你去生成，且指定属性相对应的成员变量 17.属性的默认关键字是什么？默认关键字，基本数据：atomic、readwrite、assgin普通OC对象：atomic、readwrite、strongreadwrite：可读可写，需生成getter和setter方法readOnly：只读，只生成getter，不希望属性在类外改变assgin：赋值特性。setter方法传入参数赋值给实例变量，仅设置变量时，assgin用于基本数据类型retain（MRC）/strong（ARC）：表示持有特性，setter方法将传入的参数保留，再赋值，传入参数的retaincount加1copy：拷贝特性，setter方法将传入的对象拷贝一份nonatomic：费原子特性，决定编译器生成的setter和getter方法是否非原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。 18.NSString为什么要用关键字copy，如果用Strong会有说私什么问题？1、用strong修饰不可变类型，例如：str1（NSString），使用str2（NSMutableString）赋值给str1，再修改str2的值，str1的值也会改变。strong让对象的引用计数加1，并返回当前对象的内容与地址。（指针地相同，内容是一份）2、用copy修饰，str1（NSString），使用str2（NSMutableString）赋值给str1，再修改str2的值，str1的值不会改变。copy只是拷贝一份内容，并返回指针给str1，当修改str2时，str1内容不变。str1的地址与str2的地址是不一样的，是两份内容。 19.如何令自己写的对象具有拷贝功能？如想让自己类具有copy方法，并且返回不可变类型，必须遵循NSCopying协议，并实现copyWithZone:(NSString)zone。如想让自己类具备NSMutableCopy方法，并且返回可变，必须遵循NSMutableCopying，并且实现-(void)MutableCopyZone:(nulltable NSZone*)zone; ##20.为什么IBOutle修饰的UIView也适用weak关键字？在XIB或者SB控件时，其实控件就是加载到父控件的subViews数组中，进行强引用，使用weak为了不造成循环引用。 21.nonatomic与atomic区别？atomic能绝对保证线程安全吗？如不是，应如何实现？nonatomic：非原子，不安全，但效率高atomic：原子，安全，但效率低atomic不能绝对保证线程安全。当前线程访问时，会造成线程不安全，可使用线程锁来保证线程安全。 22.用SB开发有何弊端，如何避免？简单逻辑界面开发，使用SB开发，开发比较快但当逻辑比较复杂的界面，开发就比较慢了，不不适用多人开发，不利于版本更新和后期的维护，使用SB编译时，直接加载到内存中，造成内存浪费可用XIB代替，复杂的逻辑界面可使用纯代码编写 23.可变集合类和不可变集合类的copy与mutableCopy有什么区别？可变使用copy表示深拷贝，不可变使用copy表示浅拷贝。不可变使用mutableCopy表示深拷贝。当浅拷贝，容器内容不可复制（只复制指针地址）。深拷贝，容器内容都会收到一条copy消息，拷贝出新的尼内容，重新组成新容器返回 24.进程和线程区别？同步异步区别？并行并发区别？进程：是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位线程：进程的一个实体，是CPU调度和分派的基本单位，它比进程更小的能独立运行的基本单位。线程自己基本不用有系统资源，只拥有一点运行中必不可少的资源，但它与同属一个进程的其他线程共享所拥有的全部资源。同步：阻塞当前线程操作，不能开辟线程异步：不阻碍线程继续操作，可以开辟线程执行任务并发：当有多个线程操作时，系统只有一个CPU，不可能真正同时进行一个以上的线程，它只有把CPU运行时间划为若干个时间段，再讲时间段分配给各个线程执行。在一个时间段代码运行时，其他线程处于挂起状态，这种方式称为并发并行：当系统有一个及以上的CPU，线程操作有可能非并发。当一个CPU执行一个线程时，另一个CPU执行另一个线程，两个线程互不抢占CPU资源，可同时进行，称为并行区别：并行，同一时间多个事件同时执行。并发：同一时间段多个事件发生 25.线程间通信？当使用dispatch_async函数（异步）执行任务完成时，需要使用dispatch_async（dispatch_get_mian_queue,^()）;函数会回到主线程完成UI刷新，并完成通信 26.如何使用队列来便面资源抢夺当我们使用多线程访问同一个数据时，有可能造成数据不准确性。这时使用线程锁绑定，也可以用串行队列完成 27.数据持久化几个方案plist：存储字典、数组比较好用preference：偏好设置，实质也是plistNSKeyedArchiver：归档，可存储对象Sqlite：数据库，经常使用第三方来操作（FMDB）CoreData：数据存储，官方 28.AppDelegate几个方法？从后台到前台调用哪些方法？第一次启动调用哪些？从前台到后台调用哪些方法？点击图标 –&gt; 执行main函数 –&gt; 通过UIApplication函数 –&gt; 初始化UIApplication对象并对它设置代理对象 –&gt; UIApplication对象 –&gt; 程序结束退出 对象代理：applicationDidFinishLauching（程序载入后） applicationDidEnterBackground（推送到后台） applicationWillReignActive（将进入非活动状态） applicationWillEnterBackground(从后台将进入前台) applicationDidBecomeActive（进入活动状态） applicationDidReceiveMemoryWarining（内存不足将终止） 29.NSCache优于NSDictionary的有几点？1、NSCache可自动释放内存2、NSCache线程安全，可在不同线程中添加，删除和查询缓存中的对象3、缓存对象不会拷贝key对象 30.Objc使用什么机制管理对象内存？使用内存管理计数器来管理内存。当内存管理计数器为0时，对象会被释放。 31.block实质，一共有集中block，什么情况下会生成？block实质就是一个Object-C对象block：存储位置，1、代码区；2、堆区；3、栈区；（ARC情况下会自动拷贝到堆区，因此ARC下只要堆区和栈区）。代码区：不访问栈区变量（如局部变量）且不访问堆区变量（alloc创建的对象），此时block存放在代码区。堆区：访问了处于栈区的变量，或者堆区的变量，此时block存放在堆区。需要注意实际放在栈区，在ARC情况下自动拷贝到堆区，如不是ARC则存在放栈区。所在函数执行完毕就会释放。想在外面调用需要用copy指向它，这样就拷贝到堆区strong属性不会拷贝，会造成野指针错区。 32.为什么默认情况下无法修改被block捕获的变量？__block都做了什么？默认情况下，block里的变量，拷贝进去是变量的值，而不是指向变量的指针。当使用__block修饰后的变量，拷贝到block里面就是指向变量的指针，所以我们可以修改变量的值 33.Objc在向一个对象发送消息时，发生了什么？根据对象的isa指针找到了类对象id，在查询类对象里面的methodLists方法函数列表，如果没有在，再沿着superClass寻找父类，再在父类methodLists方法的列表中查询，最终找到SEL，根据SEL确认IMP（指针函数），再发送消息。 34.block和weak修饰符的区别？1、block不管是MRC还是ARC都可以使用，不仅可以修饰对象也可以修饰数据类型2、weak只能在ARC模式下使用，也只能修饰对象3、block对象可在block中被赋值，而weak不行 35.什么时候报unrecognized selector 错误？iOS什么机制可以避免？当发送消息时，会根据类里面的methodLists列表去查询我们动用的SEL，当查询不到时，我们一直沿着父类查询，最终查询不到时，会报此错误。查询不到方法调用+(void)resolveInstancemethod:(SEL)sel动态解释方法来给我一次机会添加，调用不到方法，可以再用-(void)forwardingForSelector:(SEL)selector重定向的方法来告诉系统，该用什么方法，保证不会崩溃。 36.常见HTTP状态码有哪些？302请求重定向；500以上服务器错误；400以上请求连接错误或者找不到服务器；200以上正确；100以上请求接收成功 37.static关键字的作用？1、函数体内static变量的作用范围为该函数体不同于auto变量，该变量只被分配一次，因此其值在下次调用时仍维持上一次的值。2、在模块内的static全局变量可以被模块所用函数所访问，但不能改变模块外的其他函数访问 38.OC能多继承么？OC中类不能多继承，可实现多个接口，通过多个接口完成C++多重继承，category为类别，重写一个类用分类好，category去重写类的方法，仅对本category有效，不会影响其他类和原有类的关系 39. #import和、#include和@class1、#import是OC导入OC头文件的关键字，#include是C/C++导入头文件的关键字。使用#import只导入一次，不会重复导入2、@class告诉编译器某个类的声明，执行时，才去查看类的实现文件，可解决头文件的相互包含，#import&lt;&gt;用来包含系统文件，#import””用来包含用户头文件 40.redwrite、readOnly、assgin、retain、copy、nonatomicredwrite：表示可读可写，生成getter和setter方法readOnly：表示只读，只生成getter，不生成setterassgin：表示赋值特性，setter方法将参数赋值给实例变量，仅设置变量时retain：表示持有特性，setter方法传入参数保留，再赋值传入参数的retaincount会+1copy：表示赋值特性，setter方法将传入的对象复制一份，再赋值传入的参数的retaincount会+1nonatomic：非原子操作，atomic表示多线程安全，一般使用nonatomic 41.id声明的对象有什么特性？id声明的对象具有运行时的特性，既可以指向任何类型的OC对象 42.OC的内存管理，看法与解决方法？自动计数器，这个方式与java相似，在程序运行时，始终自动释放，alloc-init 方式创建，retain加一，release减一手动内存计数，自己创建自己销毁 43.类别作用？继承和类别在实现中的区别？类别有三个作用：①将类的实现分散到不同文件或者不同框架中。②创建对私有方法的前向引用。③向对象添加非正式协议集成可以增加，修改或者删除方法，并且可以增加属性 44.Block和delegate的区别Block比delegate的成本高，因为block需要将数据从栈内复制到堆内，对象计数会增加，直到使用完成，block置nil才能消除，而delegate只是保留对象指针，直接回调就可以block轻量级delegate重量级，易造成循环引用 45.项目中网络层如何做安全处理1、尽量使用https；2、不要传输明文密码；3、post并不比get安全；4、不要使用301跳转；5、http请求头带上MAC；6、http请求使用临时密钥；7、AES使用CBC模式 46.mian()之前的过程有哪些？1、dyld开始将程序二进制文件初始化2、交由ImageLoader读取image，其中包括我们的类，方法等各种符号（class，protocol，selector，IMP）3、由于runtime向dyld绑定回调，当image加载到内存后，dyld会通知runtime进行处理4、runtime接手后调用map-image做解析处理5、接下来load-image中调用call-load-methods方法遍历所有加载进来的class，按集成层析依次调用class的+load和其他category的+load方法6、至此所有信息都被加载到内存卡7、最后dyld调用真正的main函数 47.设计模式哪几种设计模式一种编码经验，用比较成熟的逻辑处理某类型的事 ①MVC：model-view-controller 模型-视图-控制器进行解耦和编写；②MVVM：model-view-viewModel把 模型视图，业务逻辑层进行解耦和编写；③单例模式：通过static关键字，声明全局变量，在整个过程运行期间只会被赋值一次；④观察者模式：KVO是典型的通知模式，观察某个属性状态发生变化时通知观察者；⑤委托模式：代理+协议，实现一对一反向传值操作；⑥工厂模式：通过一个方法，批量的根据已有模板生产对象 48.frame和bounds的区别frame：该view在父类view坐标中位置和大小；bounds是该view在自身坐标的位置和大小 49.OC的类可多重继承吗？可以实现多个接口吗？Category是什么？重写一个类的方法用继承好还是分类好？为什么？OC的类不可以多重继承，可以实现多个接口，category是类别，一般情况用分类好，用category去重写类方法，仅对本category有效，不会影响其他类以及原有类的关系。 50.@property本质是什么？ivar、getter、setter、如何生成并添加到这个类中？@property = ivar+getter+setter属性两大概念：ivar（实例变量）、getter+setter（存取方法）属性作为OC一项特性，主要的作用在于封装对象的数据。OC对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”来访问。其中，“存取方法”（getter）读取变量，而“设置方法”setter用于写入变量。 51.什么情况用weak关键字，相比assgin有什么不同？1、在ARC中，在有可能出现循环引用的时候，往往通过让其中一端使用weak来解决，比如delegate属性2、自身已经对它进行一次强引用，没有必要再强引用一次，此时也会用weak，自定义IBOutle控件属性一般也是用weak，当然也可以使用strong。IBOutle连线出来的视图属性设置为weak，因为父控件的subViews数组已经对它有一个强引用：不同点：assgin可以用非OC对象，而weak必须用于OC对象；weak表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性会自动清空（nil）。 52.怎么用copy关键字1、NSString、NSArray、NSDictionary常用copy，是因为它们有对应的可变类NSMutableString、NSMutableArray、NSMutableDictionary2、block也常用copy 53.NSString、NSArray、NSDictionary为什么常用copy？如果用strong会如何？因为它们有相应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，它们之间可能进行赋值操作（就是把可变赋值给不可变的）为确保对象中的字符中的值不会无意间的而变动，应该在设置新属性时先拷贝一份1、因为父类指针可以指向子类对象，使用copy目的是为了让本队形的属性不受外界影响，使用copy无论给我传入一个可变对象还是不可变对象，我本身持有对象就是不可变副本。2、如果我们使用strong，那么这个属性就有可能指向一个可变对象，如果这个可变对象在外部被修改，那么会影响该属性总结：使用copy的目的是为了防止可变类型的对象赋值给不可变类型的对象，可变类型的对象的值发送变化会无意间篡改不可变类型对象原来的值。 54.深拷贝与浅拷贝的区别？浅拷贝：只复制对象的指针，不复制对象本身深拷贝：复制对象本身，内存中有存在两个独立的对象本身，当修改A，A_copy不会变 55.系统对象的copy与mutableCopy方法？不管是集合对象（NSArray、NSDictionary、NSSet……之类）的对象还是非集合对象（NSString，NSNumber）接受到 copy和mutableCopy消息时，都遵循以下准则：①copy返回时不可变对象；如果copy返回值调用mutable对象方法时就carsh②mutableCopy返回可变对象一、在非集合对象中不可变copy是指针复制，mutableCopy是内容复制；可变都是内容复制二、集合对象中，不可变copy是指针复制，mutableCopy是内容复制；可变都是内容复制，但是集合对象复制仅限于本身，对于其中元素仍然是指针复制总结：只有对不可变进行copy操作是指针复制（浅拷贝）其他都是内容复制（深拷贝） 56.@property(nonatomic,copy) NSMutableArray *arr;将copy改为mutablecopy会出什么问题？添加，删除，修改数组内元素时，程序会因为找不到对应方法而carshcopy是复制一个NSArray对象，而NSArray对象无法进行添加修改 57.如何让自己的类用copy修饰符，如何重写带copy关键字的setter？1、需要声明遵循NSCopying协议2、实现NSCopying协议的方法，该方法只有一个方法：-(id) copyWithZone:(NSZone *)zone,使用copy修饰符，调用copy方法，其实真正实现CopyWithZone方法 58.@synthesize和@dynamic分别什么作用？@property有这两个对应的词，默认是@synthesize，它是如果没有手动生成setter和getter方法会帮忙主动加上，而@dynamic只能手动生成 59.常见的OC数据类型有哪些？与C的基本数据类型有什么区别？比如：NSInteger和intOC数据类型：NSString、NSNumber、NSArray、NSMutableArray、NSData等这些都是class，创建后便是对象。C语言基本数据类型是int，只是一定字节的内存空间，用于存放数值；NSIntger是基本数据类型Int或Long的别名，区别在于NSInteger会根据系统是32位还是64位来决定本身是int或long 60.id声明对象的特性？id声明对象具有运行时特性，可指向任意类型的OC对象 61.OC如何内存管理？看法与解决方案OC内存管理三种方式：ARC、MRC、内存池①ARC：自动内存计数，由Xcode自动在APP编译阶段，在代码中添加内存管理代码②MRC：手动内存计数，遵循内存管理谁申请，谁持有，谁释放③内存池：ReleasePool，把需要释放的内存统一放在一个池子中，当池子被抽干（drain），池子中的所有内容也被自动释放，内存池操作为手动与自动，自动释放runpool机制影响 62.OC创建线程方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码是什么方法？三种创建：NSThread、GCD的dispath、子类化的NSOperation然后加入NSOperationQueue主线程：performSelectorOnMainThread延时：performSelector：OnThread：withObject：waitUntilDone； 63.category（类别）Extension（扩展）和继承的区别①分类有名字，类扩展没有名字，是一种特殊的分类②分类只能扩展方法（属性仅仅声明，并未真的实现），类扩展可以扩展属性，成员变量和方法③继承可以增加，修改，删除方法，并且可以增加属性 64.OC是动态运行时语言是什么意思？主要讲数据类型的确定由编译时，推迟到了运行时，简单的说，运行机制使我们直到运行时才去决定一个对象的类别，以及调用该对象指定方法 65.为啥我们常见的delegate属性都用weak而不是retain/strong？为了防止delegate两端产生不必要的循环使用 66.什么时候用Delegate，什么时候用NotificationDelegate（委托模式）：1对1，反向消息通知功能Notification（通知模式）：只想要把消息传出去，告知某些状态的变化 67.KVO、KVC是什么？KVO：键值编码是一种通过字符串间接访问对象的方式KVC：键值观察机制，提供了观察某一属性变化的方法，极大简化代码 68.KVC底层实现当一个对象调用setValue方法时，方法内部操作①检查是否存在相应的Key的set方法，如存在就调用setter②如果set方法不存在，就查找与Key相同名称并且带下划线的成员变量，如果有则直接给成员变量属性赋值③如果没有找到_key，就查找相同名称的属性key，如有则直接赋值④如果还没有，则调用valueForUndefinedKey：和setValue：forUndefinedKey：方法，这些方法实则都是抛出异常，可以根据需要重写 69.ViewController生命周期1、initWithCoder：通过nib文件初始化时触发2、awakeForNib：nib文件被加载时，发送awakeForNib消息给文件美每个对象3、loadView：开始加载视图控制器自带view4、viewDidload：视图控制器的view被加载完成5、viewWillAppear：视图控制器的view将被显示在window上6、updateViewConstrains：试图控制器的view开始更新AutoLayout约束7、viewWillLayoutSubViews：试图控制器的view将更新内容视图的位置8、viewDidLayoutSubViews：视图控制器的view已经更新试图位置9、viewDidAppear：视图控制器的veiw已展示在window上10、viewWillDisappear：视图控制器的view将从window上消失11、viewDidDisappear：视图控制器的view已从widow上消失 70.方法和选择器有什么区别？selector是方法的名字，方法是以一个组合体，包含名字和实现 71.你是否接触过OC中的反射机制？简单聊一下概念和使用①class 反射Class class = NSClassFromString(@”student”);Student dtu = [[Class alloc]init];将类名变为字符串Class class = [Student class];NSString className = NSStringFromClass(class);②SEL反射通过方法的字符串形式实例化方法SEL selector = NSSSelectorFromString(@”setName”);[stu performSelector:selector withObject:@”Mike”];将方法变成字符串NSStringFromSelector(@selector *(setName)); 72. 调用方法两张方式①直接通过方法名调用[Person show];②间接通过SEL数据来调用SEL aaa = @selector(show);[Person performSelector:aaa]; 73.类变量的@public，@protected，@private，@package声明各有声明含义？@public ：任何地方都可以访问@protected ：该类和子类中访问，是默认的@private ：只能在本类中访问@package ：本包内使用，跨包不行 74.什么是谓词？谓词是通过NSPredicate给定的逻辑条件来作为约束条件，完成对数据的筛选//定义谓词对象，谓词对象中包含了过滤条件（过滤条件比较多）NSPredicate predicate = [NSPedicate predicateWthForm:@”age%d”,30];//使用谓词条件过滤数组中的元素，过滤之后返回查询的结果NSArray array = [persons filteredArrayUsingPredicate:predicate]; 75.指针问题isa：是一个Class类型的指针，每个实例对象有个isa的指针，它指向对象的类，而class里也有个isa的指针，它指向meteClass（元类）。元类保存了类方法的列表。当类方调用时，先会从本身查找类方法的实现，如没有，元类会向它父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针，它的isa指针最终指向一个根元类（root meteClass）。根元类的isa指针指向本身，这样形成一个闭环。 76.如何访问并修改一个类的私有属性？①一种是通过KVC获取②通过runtime访问修改私有属性 77.isKindOfClass，isMemberOfClass,selector作用分别是？isKindOfClass：作用是某个对象属于某个类型或者继承自某类型isMemberOfClass：某个对象确切属于某个类型selector：通过方法名，获取在内存中的函数的入口地址 78.你经常使用一些第三方库有哪些?1.AFNetworking 2.SDWebImage 3.FMDB (没怎么用，得学习) 4.JSONKit 5.MJRefresh 6.MJExtension（需要再复习） 7.Masonry 8.友盟，shareSDK等三方库。 79.你经常用的设计模式有哪些？1.MVC 2.代理模式 (Delegate) 3.观察者模式 (NSNotification/KVO) 4.单例模式 (需要多使用) 5.工厂模式 – 简单工厂，工厂方法， 抽象工厂三种设计模式(需要多使用) 80.本地存储有哪些方式？1.属性列表（NSUserDefault 或 plist） 2.对象归档 （NSKeyedArchiver） 3.SQLite 4.CoreData]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础内存管理]]></title>
    <url>%2F2018%2F11%2F07%2FiOS%E5%9F%BA%E7%A1%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理之基础篇 前言现在iOS开发已经是ARC甚至是swift的时代了，但是内存管理仍然是一个需要重点关注的问题。 内存管理是序设计中很重要的一部分，程序在运行的过程中消耗内存，运行结束后释放占用的内存。如果程序运行时一直分配内存而不及时释放无用的内存，会造成这样的后果：程序占用的内存越来越大，直至内存消耗殚尽，程序因无内存可用导致崩溃，这样的情况我们称之为内存泄漏。 ObjC的内存管理比较简洁，然而要深刻理解也不是一件易事，本文将介绍如何使用ObjC进行内存管理。 引用计数在objC中，对象什么时候被释放（或者对象占用的内存什么时候会被回收利用）？ 答案是：当对象没有被任何变量引用（也可以说是没有指针指向该对象）的时候，就会被释放。 那怎么知道对象已经没有被引用了呢？ ObjC采用引用计数（reference counting）的技术来进行管理： 每个对象都有一个关联的整数，称为引用计数器 当代码需要使用该对象时，则将对象的引用计数加1 当代码结束使用该对象时，则将对象的引用计数减1 当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放 与之对应的消息发送方法如下： 当对象被创建（通过alloc、new或copy等方法）时，其引用计数初始值为1 给对象发送retain消息，其引用计数加1 给对象发送release消息，其引用计数减1 当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象 下面通过一个简单的例子来说明: 场景：有一个宠物中心（内存），可以派出小动物（对象）陪小朋友们玩耍（对象引用者），现在xiaoming想和小狗一起玩耍。 新建Dog类，重写其创建和销毁的方法 12345678910111213141516@implementation Dog - (instancetype)init &#123; if (self = [super init]) &#123; NSLog(@&quot;小狗被派出去啦！初始引用计数为 %ld&quot;,self.retainCount); &#125; return self; &#125; - (void)dealloc &#123; NSLog(@&quot;小狗回到宠物中心&quot;); [super dealloc]; &#125; @end //在main方法中创建dog对象，給dog发送消息 12345678910111213141516//模拟：宠物中心派出小狗Dog * dog = [[Dog alloc]init];//模拟：xiaoming需要和小狗玩耍，需要将其引用计数加1[dog retain];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//模拟：xiaoming不和小狗玩耍了，需要将其引用计数减1[dog release];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//没人需要和小狗玩耍了，将其引用计数减1[dog release];//将指针置nil，否则变为野指针dog = nil; 输出结果为: 1234[34691:7638855] 初始引用计数为 1[34691:7638855] 小狗的引用计数为 2[34691:7638855] 小狗的引用计数为 1[34691:7638855] 销毁Dog 可以看到，引用计数帮助宠物中心很好的标记了小狗的使用状态，在完成任务的时候及时收回到宠物中心。 思考几个问题： 1、NSString引用计数问题，如果我们尝试查看一个string的引用计数 12NSString * str = @&quot;hello guys&quot;;NSLog(@&quot;%ld&quot;, str.retainCount); 会发现引用计数为－1，这可以理解为NSString实际上是一个字符串常量，是没有引用计数的（或者它的引用计数是一个很大的值（使用%lu可以打印查看），对它做引用计数操作没实质上的影响）。 2、赋值不会拥有某个对象 1NSString * name = dog.name; 这里仅仅是指针赋值操作，并不会增加name的引用计数，需要持有对象必须要发送retain消息。 3、dealloc，由于释放对象是会调用dealloc方法，因此重写dealloc方法来查看对象释放的情况，如果没有调用则会造成内存泄露。在上面的例子中我们通过重写dealloc让小狗被释放的时候打印日志来告诉我们已经完成释放。 4、在上面例子中，如果我们增加这样一个操作 123没人需要和小狗玩耍了，将其引用计数减1[dog release];NSLog(@&quot;%ld&quot;,dog.retainCount); 会发现获取到的引用计数为1，为什么不是0呢？ 解释：这是因为对引用计数为1的对象release时，系统知道该对象将被回收，就不会再对该对象的引用计数进行减1操作，这样可以增加对象回收的效率。另外，对已释放的对象发送消息是不可取的，因为对象的内存已被回收，如果发送消息时，该内存已经被其他对象使用了，得到的结果是无法确定的，甚至会造成崩溃。 自动释放池现在已经明确了，当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用（比如xiaoming和小狗玩耍结束的时间不确定），这可怎么办？ ObjC提供autorelease方法来解决这个问题，当給一个对象发送autorelease消息时，方法会在未来某个时间給这个对象发送release消息将其释放，在这个时间段内，对象还是可以使用的。 autorelease的原理是什么呢？原理：对象接收到autorelease消息时，它会被添加到了当前的自动释放池中，当自动释放池被销毁时，会給池里所有的对象发送release消息。 这里就引出了自动释放池这个概念，什么是自动释放池呢？ 顾名思义，就是一个池，这个池可以容纳对象，而且可以自动释放，这就大大增加了我们处理对象的灵活性。 自动释放池怎样创建？ObjC提供两种方法创建自动释放池： 方法一：使用NSAutoreleasePool来创建 123NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];//这里写代码[pool release]; 方法二：使用@autoreleasepool创建 123@autoreleasepool &#123;//这里写代码&#125; 自动释放池创建后，就会成为活动的池子，释放池子后，池子将释放其所包含的所有对象。以上两种方法推荐第一种，因为将内存交给ObjC管理更高效。 自动释放池什么时候创建？app使用过程中，会定期自动生成和销毁自动释放池，一般是在程序事件处理之前创建，当然我们也可以自行创建自动释放池，来达到我们一些特定的目的。 自动释放池什么时候销毁？自动释放池的销毁时间是确定的，一般是在程序事件处理之后释放，或者由我们自己手动释放。 下面举例说明自动释放池的工作流程：场景：现在xiaoming和xiaohong都想和小狗一起玩耍，但是他们的需求不一样，他们的玩耍时间不一样，流程如下: 1234567891011121314151617181920212223242526//创建一个自动释放池NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];//模拟：宠物中心派出小狗Dog * dog = [[Dog alloc]init];//模拟：xiaoming需要和小狗玩耍，需要将其引用计数加1[dog retain];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//模拟：xiaohong需要和小狗玩耍，需要将其引用计数加1[dog retain];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//模拟：xiaoming确定不想和小狗玩耍了，需要将其引用计数减1[dog release];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//模拟：xiaohong不确定何时不想和小狗玩耍了，将其设置为自动释放[dog autorelease];NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount);//没人需要和小狗玩耍了，将其引用计数减1[dog release];NSLog(@&quot;释放池子&quot;);[pool release]; 1234567891011121314151617181920212223242526//创建一个自动释放池 @autoreleasepool &#123; //模拟：宠物中心派出小狗 Dog * dog = [[Dog alloc]init]; //模拟：xiaoming需要和小狗玩耍，需要将其引用计数加1 [dog retain]; NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount); //模拟：xiaohong需要和小狗玩耍，需要将其引用计数加1 [dog retain]; NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount); //模拟：xiaoming确定不想和小狗玩耍了，需要将其引用计数减1 [dog release]; NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount); //模拟：xiaohong不确定何时不想和小狗玩耍了，将其设置为自动释放 [dog autorelease]; NSLog(@&quot;小狗的引用计数为 %ld&quot;,dog.retainCount); //没人需要和小狗玩耍了，将其引用计数减1 [dog release]; NSLog(@&quot;释放池子&quot;); &#125; 输出结果如下： 1234567[34819:7801589] 初始引用计数为 1[34819:7801589] 小狗的引用计数为 2[34819:7801589] 小狗的引用计数为 3[34819:7801589] 小狗的引用计数为 2[34819:7801589] 小狗的引用计数为 2[34819:7801589] 释放池子[34819:7801589] 销毁Dog 可以看到，当池子释放后，dog对象才被释放，因此在池子释放之前，xiaohong都可以尽情地和小狗玩耍。 使用自动释放池需要注意： 自动释放池实质上只是在释放的时候給池中所有对象对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，对象就无法销毁。 自动释放池中的对象会集中同一时间释放，如果操作需要生成的对象较多占用内存空间大，可以使用多个释放池来进行优化。比如在一个循环中需要创建大量的临时变量，可以创建内部的池子来降低内存占用峰值。 autorelease不会改变对象的引用计数 自动释放池的常见问题：在管理对象释放的问题上，自动帮助我们释放池节省了大量的时间，但是有时候它却未必会达到我们期望的效果，比如在一个循环事件中，如果循环次数较大或者事件处理占用内存较大，就会导致内存占用不断增长，可能会导致不希望看到的后果。 示例代码： 1234for (int i = 0; i &lt; 100000; i ++) &#123; NSString * log = [NSString stringWithFormat:@&quot;%d&quot;, i]; NSLog(@&quot;%@&quot;, log);&#125; 前面讲过，自动释放池的释放时间是确定的，这个例子中自动释放池会在循环事件结束时释放，那问题来了：在这个十万次的循环中，每次都会生成一个字符串并打印，这些字符串对象都放在池子中并直到循环结束才会释放，因此在循环期间内存不增长。 这类问题的解决方案是在循环中创建新的自动释放池，多少个循环释放一次由我们自行决定。 123456for (int i = 0; i &lt; 100000; i ++) &#123; @autoreleasepool &#123; NSString * log = [NSString stringWithFormat:@&quot;%d&quot;, i]; NSLog(@&quot;%@&quot;, log); &#125; &#125; iOS的内存管理规则基本原则无规矩不成方圆，在iOS开发中也存在规则来约束开发者进行内存管理，总的来讲有三点： 1.当你通过new、alloc或copy方法创建一个对象时，它的引用计数为1，当不再使用该对象时，应该向对象发送release或者autorelease消息释放对象。 2.当你通过其他方法获得一个对象时，如果对象引用计数为1且被设置为autorelease，则不需要执行任何释放对象的操作； 3.如果你打算取得对象所有权，就需要保留对象并在操作完成之后释放，且必须保证retain和release的次数对等。 应用到文章开头的例子中，小朋友每申请一个小狗（生成对象），最后都要归还到宠物中心（释放对象），如果只申请而不归还（对象创建了没有释放），那宠物中心的小狗就会越来越少（可用内存越来越少），到最后一个小狗都没有了（内存被耗尽），其他小朋友就再也没有小狗可申请了（无资源可申请使用），因此，必须要遵守规则：申请必须归还（规则1），申请几个必须归还几个（规则3），如果小狗被设定归还时间则不用小朋友主动归还（规则2）。 ARC在MRC时代，必须严格遵守以上规则，否则内存问题将成为恶魔一样的存在，然而来到ARC时代，事情似乎变得轻松了，不用再写无止尽的ratain和release似乎让开发变得轻松了，对初学者变得更友好。 ObjC2.0引入了垃圾回收机制，然而由于垃圾回收机制会对移动设备产生某些不好的影响（例如由于垃圾清理造成的卡顿），iOS并不支持这个机制，苹果的解决方案就是ARC（自动引用计数）。 iOS5以后，我们可以开启ARC模式，ARC可以理解成一位管家，这个管家会帮我们向对象发送retain和release语句，不再需要我们手动添加了，我们可以更舒心地创建或引用对象，简化内存管理步骤，节省大量的开发时间。 实际上，ARC不是垃圾回收，也并不是不需要内存管理了，它是隐式的内存管理，编译器在编译的时候会在代码插入合适的ratain和release语句，相当于在背后帮我们完成了内存管理的工作。 下面将自动释放池的例子转化成ARC来看看 12345678910@autoreleasepool &#123; Dog * dog = [[Dog alloc]init]; [xiaoming playWithDog:dog]; [xiaohong playWithDog:dog]; NSLog(@&quot;释放池子&quot;); &#125; 注意： 如果你的工程历史比较久，可以将其从MRC转换成ARC，跟上时代的步伐更好地维护 如果你的工程引用了某些不支持ARC的库，可以在Build Phases的Compile Sources将对应的m文件的编译器参数配置为-fno-objc-arc ARC能帮我们简化内存管理问题，但不代表它是万能的，还是有它不能处理的情况，这就需要我们自己手动处理，比如循环引用、非ObjC对象、Core Foundation中的malloc()或者free()等等 ARC的修饰符ARC提供四种修饰符，分别是strong, weak, autoreleasing, unsafe_unretained 1.__strong：强引用，持有所指向对象的所有权，无修饰符情况下的默认值。如需强制释放，可置nil。 比如我们常用的定时器 1NSTimer * timer = [NSTimer timerWith...]; 相当于: 1NSTimer * __strong timer = [NSTimer timerWith...]; 当不需要使用时，强制销毁定时器 12[timer invalidate];timer = nil; 2.__weak：弱引用，不持有所指向对象的所有权，引用指向的对象内存被回收之后，引用本身会置nil，避免野指针。 比如避免循环引用的弱引用声明： 1__weak __typeof(self) weakSelf = self; 3.__autoreleasing：自动释放对象的引用，一般用于传递参数 比如一个读取数据的方法 1- (void)loadData:(NSError **)error; 当你调用时会发现这样的提示 12NSError * error;[dataTool loadData:(NSError *__autoreleasing *)] 这是编译器自动帮我们插入以下代码 123NSError * error;NSError * __autoreleasing tmpErr = error;[dataTool loadData:&amp;tmpErr]; 4.__unsafe_unretained：为兼容iOS5以下版本的产物，可以理解成MRC下的weak，现在基本用不到，这里不作描述。 属性的内存管理ObjC2.0引入了@property，提供成员变量访问方法、权限、环境、内存管理类型的声明，下面主要说明ARC中属性的内存管理。 属性的参数分为三类，基本数据类型默认为(atomic,readwrite,assign)，对象类型默认为(atomic,readwrite,strong)，其中第三个参数就是该属性的内存管理方式修饰，修饰词可以是以下之一： 1.assign：直接赋值 assign一般用来修饰基本数据类型 1@property (nonatomic, assign) NSInteger count; 当然也可以修饰ObjC对象，但是不推荐，因为被assign修饰的对象释放后，指针还是指向释放前的内存，在后续操作中可能会导致内存问题引发崩溃。 2.retain：release旧值，再retain新值（引用计数＋1） retain和strong一样，都用来修饰ObjC对象。使用set方法赋值时，实质上是会先保留新值，再释放旧值，再设置新值，避免新旧值一样时导致对象被释放的的问题。 MRC写法如下: 12345- (void)setCount:(NSObject *)count &#123; [count retain]; [_count release]; _count = count;&#125; ARC对应写法: 123- (void)setCount:(NSObject *)count &#123; _count = count;&#125; 3.copy：release旧值，再copy新值（拷贝内容） 一般用来修饰String、Dict、Array等需要保护其封装性的对象，尤其是在其内容可变的情况下，因此会拷贝（深拷贝）一份内容給属性使用，避免可能造成的对源内容进行改动。 使用set方法赋值时，实质上是会先拷贝新值，再释放旧值，再设置新值。 实际上，遵守NSCopying的对象都可以使用copy，当然，如果你确定是要共用同一份可变内容，你也可以使用strong或retain。 1@property (nonatomic, copy) NSString * name; 4.weak：ARC新引入修饰词，可代替assign，比assign多增加一个特性（置nil，见上文）。 weak和strong一样用来修饰ObjC对象。使用set方法赋值时，实质上不保留新值，也不释放旧值，只设置新值。 1@property (weak) id&lt;MyDelegate&gt; delegate; Xib控件的引用 1@property (weak, nonatomic) IBOutlet UIImageView *productImage; 5.strong：ARC新引入修饰词，可代替retain 可参照retain，这里不再作描述。 block的内存管理iOS中使用block必须自己管理内存，错误的内存管理将导致循环引用等内存泄漏问题，这里主要说明在ARC下block声明和使用的时候需要注意的两点： 1.如果你使用@property去声明一个block的时候，一般使用copy来进行修饰（当然也可以不写，编译器自动进行copy操作），尽量不要使用retain。 1@property (nonatomic, copy) void(^block)(NSData * data); 2.block会对内部使用的对象进行强引用，因此在使用的时候应该确定不会引起循环引用，当然保险的做法就是添加弱引用标记。 1__weak typeof(self) weakSelf = self; 经典内存泄漏及其解决方案虽然ARC好处多多，然而也并无法避免内存泄漏问题，下面介绍在ARC中常见的内存泄漏 僵尸对象和野指针僵尸对象：内存已经被回收的对象。 野指针：指向僵尸对象的指针，向野指针发送消息会导致崩溃。 野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。例子代码：(没有出现错误的筒子多运行几遍，因为获取野指针指向的结果是不确定的) 123456Dog * dog = [[Dog alloc]init]; NSLog(@&quot;before&quot;); NSLog(@&quot;%s&quot;,object_getClassName(dog)); [dog release]; NSLog(@&quot;after&quot;); NSLog(@&quot;%s&quot;,object_getClassName(dog)); 运行结果： 1234[15184:5811062] before[15184:5811062] Dog[15184:5811062] after(lldb) 可以看到，当运行到第四行的时候崩溃了，并給出了EXC_BAD_ACCESS的提示。 解决方案： 对象已经被释放后，应将其指针置为空指针（没有指向任何对象的指针，给空指针发送消息不会报错）。 然而在实际开发中实际遇到EXC_BAD_ACCESS错误时，往往很难定位到错误点，幸好Xcode提供方便的工具給我们来定位及分析错误。 在product－scheme－edit scheme－diagnostics中将enable zombie objects勾选上，下次再出现这样的错误就可以准确定位了。 运行结果： 1234[15169:5801945] before[15169:5801945] Dog[15169:5801945] after[15169:5801945] _NSZombie_Dog 可以看到，当运行到第四行时并没有崩溃，并给出了NSZombie的提示。 在Xcode－open developer tool－Instruments打开工具集，选择Zombies工具可以对已安装的应用进行僵尸对象检测。 循环引用循环引用是ARC中最常出现的问题，对于可能引发循环引用的一些原因在iOS总结篇：影响控制器正常释放的常见问题中有提及，大家可以看看。 一般来讲循环引用也是可以使用工具来检测到的，分为两种： 在product－Analyze中使用静态分析来检测代码中可能存在循环引用的问题。 在Xcode－open developer tool－Instruments打开工具集，选择Leaks工具可以对已安装的应用进行内存泄漏检测，此工具能检测静态分析不会提示，但是到运行时才会出现的内存泄漏问题。 Leaks工具虽然强大，但是它不能检测到block循环引用导致的内存泄漏，这种情况一般需要自行排查问题（考验你的基本功时候到了），傻瓜式的方案当然是重写对象的dealloc方法来监测对象是否正常释放，来确认没有形成循环引用。 由于ARC中循环引用出现的几率相对较大，很多大神或者团队都提供了很多解决此问题的思路和方法，甚至开发了插件和类库来帮助开发者更好地检测问题，有兴趣的读者可以研究一下，是否好用，孰好孰坏就由读者自行评判了。 循环中对象占用内存大这个问题常见于循环次数较大，循环体生成的对象占用内存较大的情景。 例子代码： 1234for (int i = 0; i &lt; 10000; i ++) &#123; Person * soldier = [[Person alloc]init]; [soldier fight];&#125; 该循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏，解决方法和上文中提到的自动释放池常见问题类似：在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。 123456for (int i = 0; i &lt; 10000; i ++) &#123; @autoreleasepool &#123; Person * soldier = [[Person alloc]init]; [soldier fight]; &#125;&#125; 然而有时候autoReleasePool也不是万能的：例子：假如有2000张图片，每张1M左右，现在需要获取所有图片的尺寸，你会怎么做？ 如果这样做: 1234for (int i = 0; i &lt; 2000; i ++) &#123; CGSize size = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]].size; //add size to array &#125; 用imageNamed方法加载图片占用Cache的内存，autoReleasePool也不能释放，对此问题需要另外的解决方法，当然保险的当然是双管齐下了 123456for (int i = 0; i &lt; 2000; i ++) &#123; @autoreleasepool &#123; CGSize size = [UIImage imageWithContentsOfFile:filePath].size; //add siez to array &#125; &#125; 无限循环这个是比循环引用更极端的情况，无论你出于什么原因，当你启动了一个无限循环的时候，ARC会默认该方法用不会执行完毕，方法里面的对象就永不释放，内存无限上涨，导致内存泄漏。 例子： 12345678NSLog(@&quot;start !&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; BOOL isSucc = YES; while (isSucc) &#123; [NSThread sleepForTimeInterval:1.0]; NSLog(@&quot;create an obj&quot;); &#125; &#125;); 输出结果为: 123456789[7026:3555827] start ![7026:3556236] create an obj[7026:3556236] create an obj[7026:3556236] create an obj[7026:3556236] create an obj[7026:3555827] dealloc[7026:3556236] create an obj[7026:3556236] create an obj[7026:3556236] create an obj 可以看到，当控制器释放后该循环还在继续。]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之从面向对象的角度分析如何提高OC的代码质量]]></title>
    <url>%2F2018%2F11%2F07%2FiOS%E4%B9%8B%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98OC%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[从面向对象的角度分析如何提高OC的代码质量 理解“ 属性 ”这一概念属性（@property）是OC的一项特性 @property：编译器会自动生成实例变量和getter和setter方法 下文中，getter和setter方法合称为存取方法 For Example： 1@property (nonatomic, strong) UIView *qiShareView; 等价于 123@synthesize qiShareView = _qiShareView;- (UIView *)qiShareView;- (void)setQiShareView:(UIView *)qiShareView; 如果不希望自动生成存取方法和实例变量，那就要使用@dynamic关键字 1@dynamic qiShareView; 属性特质有四类： 1.原子性：默认为atomic nonatomic：非原子性，读写时不加同步锁 atomic：原子性，读写时加同步锁 2.读写权限：默认为readwrite readwrite：拥有getter和setter方法 readonly：仅拥有getter方法 3.内存管理： assign：对“纯量类型”做简单赋值操作（NSInteger、CGFloat等）。 strong：强拥有关系，设置方法 保留新值，并释放旧值。 weak：弱拥有关系，设置方法 不保留新值，不释放旧值。当指针指向的对象销毁时，指针置nil。 copy：拷贝拥有关系，设施方法不保留新值，将其拷贝。 unsafe_unretained：非拥有关系，目标对象被释放，指针不置为nil，这一点与assgin一样。区别于weak。 4.方法名： getter=：指定getter方法的方法名，常用 setter=：指定setter方法的方法名，不常用 例如： 1@property (nonatomic, getter=isOn) BOOL on; 在iOS开发中，99.99..%的属性都会声明为nonatomic。 一是atomic会严重影响性能， 二是atomic只能保证读/写操作的过程是可靠的，并不能保证线程安全。 二、在对象内部尽量直接访问实例变量1.实例变量（_属性名）访问对象的场景： 在init和alloc方法中，总是应该通过实例变量读写数据 没有重写setter和getter方法，也没有使用KVO监听 好处：不走OC方法的派发机制，直接访问内存读写，速度快，效率高 For Example： 123456789- (instancetype)initWithDic:(NSDictionary *)dic &#123; self = [super init]; if (self) &#123; _qi = dic[@&quot;qi&quot;]; _share = dic[@&quot;share&quot;]; &#125; return self;&#125; 2.用存取方法访问对象的场景： 重写getter/setter方法（比如：懒加载） 使用KVO监听值的改变 For Example： 123456- (UIView *)qiShareView &#123; if (!_qiShareView) &#123; _qiShareView = [UIView new]; &#125; return _qiShareView;&#125; 三、理解“对象等同性”12345NSString *aString = @&quot;iPhone 8&quot;;NSString *bString = [NSString stringWithFormat:@&quot;iPhone %i&quot;, 8];NSLog(@&quot;%d&quot;, [aString isEqual:bString]);NSLog(@&quot;%d&quot;, [aString isEqualToString:bString]);NSLog(@&quot;%d&quot;, aString == bString); 这段代码输出的是1；1；0。 ==操作符只是比较了两个指针所指对象的地址是否相同，而不是指针所指的对象的值。 所以最后一个为0。 四、以类族模式隐藏实现细节1234id maybeAnArray = @[];if ([maybeAnArray class] == [NSArray class]) &#123; //Code will never be executed&#125; 这个始终未false。原因：[maybeAnArray class]的返回永远不会是NSArray, NSArray是一个类族，返回的值一直都是NSArray的实体子类。大部分collection类都是某个类族中的抽象基类。 所以上面的if想要有机会执行的话要改成 1234id maybeAnArray = @[];if ([maybeAnArray isKindOfClass [NSArray class]) &#123; // Code probably be executed&#125; 这样判断的意思是，maybeAnArray这个对象是否是NSArray类族中的一员 使用类族的好处：可以把实现细节隐藏在一套简单的公共接口后面 五、在既有类中使用关联对象存放自定义数据先引入runtime类库1#import objc_AssociationPolicy（对象关联策略类型）: 三个方法管理关联对象：objc_setAssociatedObject（设置关联对象） 1234567891011/** * Sets an associated value for a given object using a given key and association policy. * * @param object The source object for the association. * @param key The key for the association. * @param value The value to associate with the key key for object. Pass nil to clear an existing association. * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.” */OBJC_EXPORT voidobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy) objc_getAssociatedObject（获得关联对象） 12345678910/** * Returns the value associated with a given object for a given key. * * @param object The source object for the association. * @param key The key for the association. * * @return The value associated with the key \e key for \e object. */OBJC_EXPORT id _Nullableobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) objc_removeAssociatedObjects（去除关联对象） 1234567891011121314/** * Removes all associations for a given object. * * @param object An object that maintains associated objects. * * @note The main purpose of this function is to make it easy to return an object * to a &quot;pristine state”. You should not use this function for general removal of * associations from objects, since it also removes associations that other clients * may have added to the object. Typically you should use \c objc_setAssociatedObject * with a nil value to clear an association. * */OBJC_EXPORT voidobjc_removeAssociatedObjects(id _Nonnull object) 小结： 可以通过“关联对象”机制可以把两个对象联系起来 定义关联对象可以指定内存管理策略 应用场景：只有在其他做法（代理、通知等）不可行时，才会选择使用关联对象。这种做法难于找bug。 六、理解objc_msgSend（对象的消息传递机制）首先我们要区分两个基本概念： 静态绑定（static binding）：在编译期就决定运行时所应调用的函数。代表语言：C、C++等 动态绑定（dynamic binding）：所要调用的函数直到运行期才能确定。代表语言：OC、swift等 OC是门强大的动态语言，它的动态性提现在它强大的runtime机制上。 解释：在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息后，由运行期决定究竟调用哪个方法，甚至可以在程序运行时改变，这些特性使得OC成为一门强大的动态语言。 底层实现：基于C语言函数实现。 实现的基本函数是objc_msgSend，定义如下： 1void objc_msgSend(id self, SEL cmd, ...) 这是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。 举例：git提交 1id return = [git commit:parameter]; 上面的方法会在运行时转换成如下的OC函数： 1id return = objc_msgSend(git, @selector(commit), parameter); objc_msgSend函数会在接收者所属的类中搜寻其方法列表，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。若是当前类没找到，那就沿着继承体系继续向上查找，等找到合适方法之后再跳转 ，如果最终还是找不到，那就进入消息转发（下一条具体展开）的流程去进行处理了。 可是如果每次传递消息都要把类中的方法遍历一遍，这么多消息传递加起来肯定会很耗性能。所以以下讲解OC消息传递的优化方法。 OC对消息传递的优化：快速映射表（缓存）优化： objc_msgSend在搜索这块是有做缓存的，每个OC的类都有一块这样的缓存，objc_msgSend会将匹配结果缓存在快速映射表(fast map)中，这样以来这个类一些频繁调用的方法会出现在fast map 中，不用再去一遍一遍的在方法列表中搜索了。 尾调用优化： 原理：在函数末尾调用某个不含返回值函数时，编译器会自动把栈空间的内存重新进行分配，直接释放所有调用函数内部的局部变量，存储调转至另一函数需要的指令码，然后直接进入被调用函数的地址。（从而不需要为调用函数准备额外的“栈帧”（frame stack）） 好处：最大限度的合理的分配使用的资源，避免过早发生栈溢出的现象。 （这一块偏底层，以上是小编的个人理解。路过的大神如果有更好的更深的见解，欢迎大神留言与我们讨论） 七、理解消息转发机制首先区分两个基本概念： 1 .消息传递：对象正常解读消息，传递过去（见上一条）。 2 .消息转发：对象无法解读消息，之后进行消息转发。 消息转发完整流程图： 流程解释： 第一步：调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。 第二步：调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。 第三步：调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。 最后：以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx 八、用“方法调配技术”调试“黑盒方法”方法调配（Method Swizzling）：使用另一种方法实现来替换原有的方法实现。（实际应用中，常用此技术向原有实现中添加新的功能。） 两个常用的方法： 获取给定类的指定实例方法： 1234567891011121314/** * Returns a specified instance method for a given class. * * @param cls The class you want to inspect. * @param name The selector of the method you want to retrieve. * * @return The method that corresponds to the implementation of the selector specified by * \e name for the class specified by \e cls, or \c NULL if the specified class or its * superclasses do not contain an instance method with the specified selector. * * @note This function searches superclasses for implementations, whereas \c class_copyMethodList does not. */OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name) 交换两种方法实现的方法： 12345678910111213141516/** * Exchanges the implementations of two methods. * * @param m1 Method to exchange with second method. * @param m2 Method to exchange with first method. * * @note This is an atomic version of the following: * \code * IMP imp1 = method_getImplementation(m1); * IMP imp2 = method_getImplementation(m2); * method_setImplementation(m1, imp2); * method_setImplementation(m2, imp1); * \endcode */OBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 利用这两个方法就可以交换指定类中的指定方法。在实际应用中，我们会通过这种方式为既有方法添加新功能。 For Example：交换method1与method2的方法实现 123Method method1 = class_getInstanceMethod(self, @selector(method1:));Method method2 = class_getInstanceMethod(self, @selector(method2:));method_exchangeImplementations(method1, method2); 九、理解“类对象”的用意Objective-C类是由Class类型来表示的，实质是一个指向objc_class结构体的指针。它的定义如下： 1typedef struct objc_class *Class; 在中能看到他的实现： 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; //!&lt; 指向metaClass(元类)的指针#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; //!&lt; 父类 const char * _Nonnull name OBJC2_UNAVAILABLE; //!&lt; 类名 long version OBJC2_UNAVAILABLE; //!&lt; 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; //!&lt; 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; //!&lt; 该类的实例变量大小 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; //!&lt; 该类的成员变量链表 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; //!&lt; 方法定义的链表 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; //!&lt; 方法缓存表 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; //!&lt; 协议链表#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 此结构体存放的是类的“元数据”（metadata)，例如类的实例实现了几个方法，父类是谁，具备多少实例变量等信息。 这里的isa指针指向的是另外一个类叫做元类（metaClass)。那什么是元类呢？元类是类对象的类。也可以换一种容易理解的说法： 1、当你给对象发送消息时，runtime处理时是在这个对象的类的方法列表中寻找 2、当你给类发消息时，runtime处理时是在这个类的元类的方法列表中寻找 我们来看一个很经典的图来加深理解： 可以总结如下： 1、每一个Class都有一个isa指针指向一个唯一的Meta Class（元类） 2、每一个Meta Class的isa指针都指向最上层的Meta Class，这个Meta Class是NSObject的Meta Class。(包括NSObject的Meta Class的isa指针也是指向的NSObject的Meta Class) 3、每一个Meta Class的super class指针指向它原本Class的 Super Class的Meta Class (这里最上层的NSObject的Meta Class的super class指针还是指向自己) 4、最上层的NSObject Class的super class指向 nil 转载地址]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>提高代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之ARC]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E4%B9%8BARC%2F</url>
    <content type="text"><![CDATA[ARC 内存管理ARC（自动引用计数）是iOS5、macOS10.7引入的内存管理技术，为了循序渐进的方式了解这项技术，本书先从ARC无效的环境说起，也就是常指的MRC（手动引用计数）环境。 内存管理的思考方式 自己生成的对象，自己所持有。 非自己生成的对象，自己也能持有。 不再需要自己持有的对象时释放。 非自己持有的对象无法释放。 这里的“自己”理解为编程人员自身。与“生成”、“持有”、“释放”操作并列的还有“废弃”，分别对应以下方法： 对象操作Objective-C方法生成并持有对象alloc/new/copy/mutableCopy等方法持有对象retain方法释放对象release方法废弃对象dealloc方法 注意：以上方法包含在Cocoa框架中而非Objective-C语言中。 自己生成的对象，自己所持有以下面名称开头的方法生成的对象为自己持有： alloc new copy mutableCopy 12id obj1 = [[NSObject alloc] init];// 自己生成并持有id obj2 = [NSObject new];// 自己生成并持有 另外，根据以上原则，下列方法也意味着自己生成并持有对象： allocMyObject newThatObject copyThis mutableCopyYourObject 1234567id obj = [MyObject allocMyObject]; // 内部实现+ (MyObject *)allocMyObject &#123; MyObject *obj = [[MyObject alloc] init]; return obj;&#125; 非自己生成的对象，自己也能持有alloc/new/copy/mutableCopy以外方法取得对象，非自己生成，自己不持有对象。可以通过retain方法为自己所持有。 12id obj = [NSMutableArray array];// 取得对象，但自己不持有[obj retain];// 自己持有对象 不再需要自己持有的对象时释放 自己持有的对象不再需要时，持有者有义务将其释放。释放使用release方法。 12id obj = [[NSObject alloc] init];// 自己生成并持有对象[obj release];// 释放对象 用retain方法持有对象，一旦不再需要，务必要用release方法释放。 123id obj = [NSMutableArray array];// 取得对象，但自己不持有[obj retain];// 持有非自己生成对象[obj release];// 释放对象 类似[NSMutableArray array]方法取得的对象存在，但自己不持有对象，内部如何实现？以object这个方法名为例： 12345- (id)object &#123; id obj = [[NSObject alloc] init];// 自己持有 [obj autorelease];// 适当时机自动释放 return obj;// 取得对象存在，但自己不持有&#125; autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放。 使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法是通过autorelease实现的。 非自己持有的对象无法释放用alloc/new/copy/mutableCopy方法生成并持有的对象，或用retain方法持有的对象，在不需要时要将其释放。倘若在应用程序中释放了非自己持有的对象会造成崩溃。 123456id obj = [[NSObject alloc] init];// 自己生成并持有对象[obj release];// 释放对象[obj release];// 重复释放对象，崩溃id obj1 = [obj0 object];// 取得对象，但自己不持有[obj1 release];// 释放非自己持有的对象，崩溃 alloc/retain/release/dealloc及其实现 Cocoa是macOS的系统框架，在iOS上被称为Cocoa Touch。Cocoa框架虽然没有公开，但是可以通过Cocoa框架的互换框架GNUstep来推测苹果的实现。 alloc调用allocWithZone，那么这里的参数类型NSZone是什么？ 它是为了防止内存碎片化而引入的结构。对内存分配的区域本身进行多重化的管理，根据使用对象的目的、对象的大小分配内存，从而提高内存管理的效率。 现在运行时系统中的内存管理已经极具效率，使用区域来管理内存反而会引起内存使用效率低下以及源代码复杂等问题。 GNUstep的实现GNUstep源码里alloc类方法用obj_layout结构体中的整数变量retained来保存引用计数retainCount，并将其写入对象内存头部。 执行alloc后对象的实例方法retainCount获得数值是1，retain使变量retained值+1，release使变量retained值-1。release使tetained变量大于0时-1，等于0时调用dealloc实例方法，废弃对象。 具体总结如下： 在Objective-C的对象中存有引用计数这一整数值。 调用alloc或是retain方法后，引用计数值+1。 调用release后，引用计数值-1。 引用计数值为0时，调用dealloc方法废弃对象。 苹果的实现alloc过程设置断点追踪调用的方法和函数： 1234+alloc+allocWithZone:class_createInstancecalloc//分配内存块 苹果对alloc的实现与GNUstep并无多大差异。 retainCount/retain/release调用的方法和函数分别如下： 1234567891011-retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey-retain__CFDoExternRefOperationCFBasicHashAddValue-release__CFDoExternRefOperationCFBasicHashRemoveValue （CEBasicHashRemoveValue返回0时，-release 调用dealloc） 可以从__CFDoExternRefOperation函数以及一些CFBasicHash开头的函数名看出，苹果的实现大概就是采用散列表（又称哈希表）来管理引用计数。 在引用计数表中，key为内存块地址，value为对应的引用计数，苹果这样实现的优势在于： 为对象分配内存块时无需考虑内存块头部。 对象占用内存块损坏时，可以根据引用计数表来确认内存块的位置。 检测内存泄露时，根据引用计数表中的记录检查对象的持有者是否存在。 autorelease及其实现autorelease会像C语言的自动变量那样对待对象实例。当超出其作用域时，对象实例的release实例方法被调用。 autorelease具体使用方法如下: 1.生成并持有NSAutoreleasePool对象； 2.调用已分配对象的autorelease实例方法； 3.废弃NSAutoreleasePool对象。 1234NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj release];[pool drain]; Cocoa框架中程序主循环的NSRunLoop对NSAutoreleasePool对象进行生成、持有和废弃处理。在大量产生autorelease对象时，若不废弃NSAutoreleasePool对象，那么生成的对象就不能被废弃，会产生内存不足现象。 GNUstep的实现autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法。 1[obj autorelease]; 源码： 123- (id)autorelease &#123; [NSAutoreleasePool addObject:self];&#125; GNUstep在实现NSAutoreleasePool时使用连接列表，可以理解为数组。若调用NSObject类的autorelease方法，该对象就会被追加到正在使用的NSAutoreleasePool对象的数组中。drain实例方法废弃正在使用的NSAutoreleasePool对象，会对数组中的所有对象调用release方法。 苹果的实现autoreleasepool以数组的形式实现，主要通过以下3个函数： obj_autoreleasePoolPush() obj_autorelease(obj) obj_autoreleasePoolPop(pool) 12345678910NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];/* 等同于objc_autoreleasePoolPush */ id obj = [[NSObject alloc] init]; [obj autorelease];/* 等同于 objc_autorelease(obj) */ [pool drain];/* 等同于 objc_autoreleasePoolPop(pool) */ ARCARC概述ARC（Auto Reference Counting）是iOS5、macOS10.7（OS X Lion）引入的内存管理技术。 ARC的出现解决了原来需要手动键入retain或release操作的问题。这在降低程序崩溃、内存风险的同时，很大程度上减少了开发程序的工作量。 内存管理的思考方式 “引用计数式内存管理”的本质在ARC中并没有改变，ARC只是自动地帮我们处理“引用计数”的相关部分。 所有权修饰符 ARC环境下其类型必须附加所有权修饰符（有省略的情况），所有权修饰符有以下4种： __strong __weak __unsafe_unretained __autorelease 书中此处提到id类型做一下记录： Objective-C中为了处理对象，可将变量定义为id类型，id类型用于隐藏对象类型的类名部分，相当于C语言中常用到的void *。 __strong修饰符id和对象类型默认使用__strong修饰，由于是默认情况，可省略不写。 __strong表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。 strong同weak、__autoreleasing一样，可以保证被修饰的变量在初始化时为nil。 1234id obj = [[NSObject alloc] init]; //等同于//id __strong obj = [[NSObject alloc] init]; __weak修饰符循环引用容易引起内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。使用__weak修饰符可以避免循环引用。 __weak表示弱引用，弱引用不能持有对象实例。 1id __weak obj = [[NSObject alloc] init];//编译器会警告 __weak修饰符还有另一个优点。在持有对象的弱引用时，若对象被废弃，则此弱引用将失效且处于nil被赋值的状态。 通过检查__weak修饰的变量是否为nil可以判断被赋值的对象是否已废弃。 weak只能用于iOS5和macOS10.7以上版本，在iOS4和macOS10.6及以前用unsafe_unretained代替。 __autoreleasing修饰符ARC下指定@autoreleasepool块来替代NSAutoreleasePool类生成、持有及废弃这一范围。_autoreleasing修饰变量等价于对象调用autorelease方法，即可将对象注册到autoreleasepool中。 123@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; 提问：前文提到__weak修饰的变量必须注册到autoreleasepool中，为什么？ 答：因为__weak修饰的变量只能持有对象的弱引用，在访问对象的过程中，该对象可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前能确保该对象存在。 _autoreleasing同__strong一样，显式使用罕见。 ARC的规则ARC环境下编译源代码遵循一定规则： 不能使用retain/release/retainCount/autorelease 不能使用NSAllocateObject/NSDeallocateObject ARC有效时，以上方法会导致编译器报错。 必须遵守内存管理的方法命名规则 对象的生成、持有的方法必须遵循命名规则：alloc/new/copy/mutableCopy。以init开头的方法更严格：必须是实例方法且必须返回对象，返回对象的类型必须是id类型或该方法声明类的对象类型。 不要显式调用dealloc dealloc方法无需显式调用，但C语言库需要在dealloc中free，以及删除已注册的通知观察者。 使用@autorelease块代替NSAutoreleasePool ARC有效时，使用@autoreleasepool块代替NSAutoreleasePool。 不能使用区域（NSZone） 不管ARC是否有效，区域在现在运行时系统中已单纯地被忽略。 C语言的规约上没有方法来管理结构体成员变量的生存周期。 对象型变量不能作为C语言结构体（struct/union）的成员 显式转换“id”和“void *” 123/* ARC无效 */id obj = [[NSObject alloc] init];void *p = obj ARC有效时需要通过__bridge来显式转换： 1234/* ARC有效 */id obj = [[NSObject alloc] init];void *p = (__bridge void*)obj;id o = (__bridge id)p; 属性和数组 声明属性所用的关键词与所有权修饰符的对应关系： 声明属性的关键词所有权修饰符 assign unsafe_unretained copy strong retain strong strong strong unsafe_unretained unsafe_unretained weak weak 动态数组中操作__strong修饰的变量与静态数组有很大差异，需要自己释放所有元素。静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，而在动态数组中，编译器不能确定数组的生存周期，所以无从处理。 ARC的实现__strong的实现 自己生成并持有 12345678&#123; id __strong obj = [[NSObject alloc] init];&#125;/* 编译器的模拟代码 */id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj); 非自己生成持有 123456id __strong obj = [NSMutableArray array];/* 编译器的模拟代码 */id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_release(obj); objc_retainAutoreleasedReturnValue函数用于持有对象，注册到autoreleasepool中并返回。与之对应的函数是objc_autoreleaseReturnValue。 12345678910+ (id)array &#123; return [[NSMutableArray alloc] init];&#125;/* 编译器的模拟代码 */+ (id)array &#123; id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 通过objc_retainAutoreleasedReturnValue函数和objc_autoreleaseReturnValue函数的协作，可以不将对象注册到autoreleasepool中而直接传递，以达到最优化程序运行。 __weak的实现 使用__weak修饰的变量，就是使用注册到autoreleasepool中的对象。 12345678910&#123; id __weak obj1 = obj;&#125;/* 编译器模拟代码 */id obj1;objc_initWeak(&amp;obj1, obj);id tmp = objc_loadWeakRetained(&amp;obj1);objc_autorelease(tmp);objc_destroyWeak(obj1); __weak同引用计数一样通过散列表（哈希表）实现，大致流程如下： 1.objc_initWeak(&amp;obj1, obj)函数初始化__weak修饰的变量，通过执行objc_storeWeak(&amp;obj1, obj)函数，以第一个参数（变量的地址）作为key，把第二个参数（赋值对象）作为value存入哈希表。 2.由于弱引用不能持有对象，函数objc_loadWeakRetained(&amp;obj1)取出所引用的对象并retain。 3.objc_autorelease(tmp)函数将对象注册到autoreleasepool中。 4.objc_destroyWeak(&amp;obj1)函数释放weak修饰的变量，通过过程执行objc_store(&amp;obj1, 0)函数，在weak表中查到变量地址并删除。废弃对象调用objc_clear_deallocating函数，这个过程会将weak表记录中weak修饰的变量地址赋值为nil。 如果大量使用weak修饰的变量，则会消耗相应的CPU资源。良策是只在需要避免循环引用时使用weak修饰符。 __autoreleasing的实现 12345678910@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125;/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelese(obj);objc_autoreleasePoolPop(); 以上为ARC篇的学习内容。]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之内存管理]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS之内存管理 #本篇的主题是iOS中的 “内存管理机制”。说到内存管理机制，逃不过iOS的两种内存管理机制：MRC 和 ARC。 先简单介绍一下：MRC（manual reference counting）：“手动引用计数” ，由开发者管理内存。ARC（automatic reference counting）：“自动引用计数”，从iOS 5开始支持，由编译器帮忙管理内存。 苹果引入ARC机制的原因猜测：iOS4之前，所有iOS开发者必须手动管理内存，即手动管理对象的内存分配和释放。首先，不断插入retain、release等内存管理语句，大大加大了工作量和代码量。其次，在面对一些多线程并发操作时，开发者手动管理内存并不简单，还可能会带来很多无法预知的问题。所以，苹果从iOS5开始引进ARC机制，由编译器帮忙管理内存。在编译期，编译器会自动加上内存管理语句。这样，开发者可以更加关注业务逻辑。 ##下面进入正题：内存管理。 一、理解引用计数引用计数工作原理： 这边引用我正在看的《Object-C 高级编程 iOS与OSX多线程和内存管理》这本书的例子： 经典例子： 解释：1、开灯：引申：“ 创建对象 ”。2、关灯：引申：“ 创建对象 ”。 解释：1、有人来上班打卡：开灯。– （创建对象，计数为1）2、又有人来：保持开灯。–（保持对象，计数为2）3、又有人来：保持开灯。–（保持对象，计数为3）4、有人下班了：保持开灯。–（保持对象，计数为2）5、又有人下班了：保持开灯。–（保持对象，计数为1）6、所有人都下班了：关灯。–（销毁对象，计数为0） 如果觉得本书中的例子说的有点抽象难懂，没关系，请看下面图解示例：提示：实箭头为强引用，虚箭头为弱引用 属性存取方法的内存管理 这边举一个set方法的例子： 解释：object中得到新值，_object存储着旧值。而set方法将保留新值，释放旧值，然后更新实例变量。这三个语句的顺序很重要。 如果先release再retain。那么该对象可能已经被回收，此时retain操作无效，因为对象已释放。这时实例变量就变成了悬挂指针。悬挂指针：指针指nil的指针。 自动释放池 在我们写iOS程序时，main函数里就有一个autoreleasepool（自动释放池）。 autorelease能延长对象的生命周期，在对象跨越“方法调用边界”后（就是}后）依然可以存活一段时间。 循环引用 循环引用（retain cycle）又称为“保留环”。形成循环引用的原因：是对象之间互相通过强指针指向对方（或者说互相强持有对方） 在开发中，我们不希望出现循环引用，因为会造成内存泄漏。 解决方案：有一方使用弱引用（weak reference）,解开循环引用，让多个对象得到释放。 PS：关于如何检验项目中是否有内存泄漏：1、静态内存泄漏分析方法；2、动态内存泄漏分析方法。 二、以ARC简化引用计数在ARC环境下，禁止调用：retain、release、autorelease、dealloc方法。 使用ARC时必须遵循的方法命名规则： 若方法名以alloc、new、copy、mutableCopy开头，则规定返回的对象归调用者。 变量的内存管理语义： 对比一下MRC和ARC在代码上的区别 MRC环境下： 这样会出现一种边界情况，如果新值和旧值是同一个对象，那么会先释放掉，object就变成悬挂指针。 ARC环境下： ARC会用一种更安全的方式解决边界问题：先保留新值，再释放旧值，最后更新实例变量。 同时，ARC可以通过修饰符来改变局部变量和实例变量的语义： ARC如何清理实例变量： MRC中，开发者需要在dealloc中动插入必要的清理代码（cleanup code）。 而ARC会借用Object-C++的一项特性来完成清理任务，回收OC++对象时，会调用C++的析构函数；走底层.cxx_destruct方法。而当释放OC对象时，ARC在.cxx_destruct底层方法中添加所需要的清理代码（这个方法底层的某个时机会调用dealloc方法）。 不过如果有非OC对象，还是需要写dealloc方法。比如CoreFoundation中的对象或是malloc()分配在堆中的内存依然需要清理。这时要适时调用CFRetain/CFRelease。 三、dealloc方法中只释放引用并解除监听调用dealloc方法时，对象已经处于回收状态了。这时不能调用其他方法，尤其是异步执行某些任务又要回调的方法。如果异步执行完回调的时候对象已经摧毁，会直接crash。 dealloc方法里要做些释放相关的事情，比如： 释放指向其他对象的引用。 取消订阅KVO。 取消NSNotification通知。 举个栗子: KVO: 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; //.... [webView addObserver:self forKeyPath:@&quot;canGoBack&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;canGoForward&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionNew context:nil]; [webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; self.backItem.enabled = self.webView.canGoBack; self.forwardItem.enabled = self.webView.canGoForward; self.title = self.webView.title; self.progressView.progress = self.webView.estimatedProgress; self.progressView.hidden = self.webView.estimatedProgress&gt;=1;&#125;- (void)dealloc &#123; [self.webView removeObserver:self forKeyPath:@&quot;canGoBack&quot;];//&lt; 移除KVO [self.webView removeObserver:self forKeyPath:@&quot;canGoForward&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;title&quot;]; [self.webView removeObserver:self forKeyPath:@&quot;estimatedProgress&quot;];&#125; ``` - NSNotificationCenter: (void)viewDidLoad { //…… // 添加响应通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tabBarBtnRepeatClick) name:BQTabBarButtonDidRepeatClickNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(titleBtnRepeatClick) name:BQTitleButtonDidRepeatClickNotification object:nil];} // 移除通知 (void)dealloc { // [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTabBarButtonDidRepeatClickNotification object:nil];// [[NSNotificationCenter defaultCenter] removeObserver:self name:BQTitleButtonDidRepeatClickNotification object:nil]; // 或者使用一个语句全部移除 [[NSNotificationCenter defaultCenter] removeObserver:self]; } ### 四、编写“ 异常安全代码 ”时留意内存管理问题 异常只应在发生严重错误后抛出。 用的不好会造成内存泄漏：在try块中，如果保留了某个对象，然后在释放它之前又抛出异常，那么除非catch块能解决问题，否则对象所占内存就会泄漏。 原因：C++的析构函数由Object-C的异常处理例程来运行。由于抛出异常会缩短生命周期，所以发生异常时必须析构，不然就内存泄漏，而这时如果文件句柄（file handle）等系统弄资源没有正确清理，就会发生内存泄漏。 捕获异常时，一定要将try块内所创立的对象清理干净。 ARC下，编译器默认不生成安全处理异常所需的清理代码。如要开启，请手动打开：-fobjc-arc-exceptions标志。但很影响性能。所以建议最好还是不要用。但有种情况是可以使用的:Object-C++模式。 PS:在运行期系统，C++与Object-C的异常互相兼容。也就是说其中任一语言抛出的异常，能用另一语言所编的“异常处理程序”捕获。而在编写Object-C++代码时，C++处理异常所用的代码与ARC实现的附加代码类似，编译器自动打开-fobjc-arc-exceptions标志，其性能损失不大。 最后，还是建议： * 异常只用于处理严重错误（fatal error，致命错误） * 对于一些不那么严重的错误（nofatal error，非致命错误）,有两种解决方案： 1、让对象返回nil或者0（例如：初始化的参数不合法，方法返回nil或0） 2、使用NSError ### 五、以弱引用避免循环引用（避免内存泄漏） * 为了避免因循环引用而造成内存泄漏。这时，某些引用需要设置为弱引用（weak） * 使用弱引用weak，ARC下，对象释放时，指针会置为nil。 ### 六、以 “自动释放池块” 降低内存峰值 * 默认情况下：自动释放池需要等待线程执行下一次事件循环时才清空，通常for循环会不断创建新对象加入自动释放池里，循环结束才释放。因此，可能会占用大量内存。 * 手动加入自动释放池子（@autoreleasepool）：每次for循环都会直接释放内存，从而降低了内存为峰值。 尤其，在遍历处理一些大数组或者大字典时，可以使用自动释放池来降低内存峰值，例如： NSArray qiShare = /一个很大的数组/NSMutableArray qiShareMembersArray = [NSMutableArray new];for (NSStirng name in qiShare) { @autoreleasepool { QiShareMember member = [QiShareMember alloc] initWithName:name]; [qiShareMembersArray addObject:member]; }}```PS：自动释放池的原理：排布在“栈”中，对象执行autorelease消息后，系统将其放入最顶端的池里（进栈），而清空自动释放池就是把对象销毁（出栈）。而调用出栈的时机：就是当前线程执行下一次事件循环时。 七、用 “僵尸对象” 调试内存管理问题 如上图，勾选这里可以开启僵尸对象设置。开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类（zombie class），变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序。 僵尸对象简单原理：在Objective-C的运行期程序库、Foundation框架以及CoreFoundation框架的底层加入了实现代码。在系统即将回收对象时，通过一个环境变量NSZombieEnabled识别是僵尸对象——不彻底回收，isa指针指向僵尸类并且响应所有选择子。 八、不要使用retainCount在苹果引入ARC之后retainCount已经正式废弃，任何时候都没法调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了（而且在ARC环境下也调用不了）。但是在MRC下还是可以正常使用的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS腾讯Bugly使用]]></title>
    <url>%2F2018%2F11%2F06%2FiOS%E8%85%BE%E8%AE%AFBugly%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#iOS腾讯Bugly使用 Bugly 创建 首先进入Bugly官网：Bugly官网,点击立即接入，用qq登陆后点击我的产品，新建一个产品，然后填写产品信息，保存 然后将Bugly集成到项目中，这里我用的是cocoapods 集成的Bugly pod &apos;Bugly&apos; 然后在工程中初始化Bugly，一句代码搞定APPID是必填的，在我的产品中点击设置获取 配置完成之后运行出现bug后就可以捕获异常了，在崩溃分析中查看，但是我们只看到了在哪个方法里里报错，并不知道崩溃具体在哪一行，所以我们还要配置符号表 关于符号表官网有详细介绍如何使用： 符号表 上传符号表：两种方式，分别是自动跟手动自动配置: 不需要java运行环境，在脚本里面填写相关信息， 直接在Xcode编译执行脚本即可，官网上有写，非常方便简单，但在编译的时候比较慢重点讲下手动配置： 官方的符号表工具iOS文档版­使用指南不是很通俗易懂，下面我再写一个更直观的教程，方便大家阅读。 配置环境 点击Java运行环境下载(JRE或JDK版本需要&gt;=1.6，我下的是9.0.4) 。 安装过后,查看是否安装成功，打开终端,在终端输入java -version 获取dSYM文件 dSYM文件是指具有调试信息的目标文件,在Products里面右击 Show in Finder 如图所示，如果编译后没有dSYM文件说明是Dug编译的，如果要在Debug环境也能成dSYM文件，所以要做如下设置: 实际项目中我没有设置，因为我是通过打包后获取的dSYM文件 生成符号表文件 3.1下载最新版Bugly iOS符号表工具 选一个位置创建一个文件夹，将”buglySymboliOS.jar”放入文件夹里面 ，我自己是在桌面创建了”testBugly”,然后将”buglySymboliOS.jar”放入进去了 最后使用JAR包跟dSYM在终端生成符号表文件 在终端执行以下命令:java -jar jar包路径 -i dSYM文件路径 上传符号表到到我产品。如图: 之前用自动符号表生成了一些，所以符号表文件有点多。 最后就可以在项目中愉快的看到bug出现在哪个类哪一行代码上了]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Bugly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode10升级后的问题]]></title>
    <url>%2F2018%2F11%2F05%2FXcode10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Xcode 10 Error 重复的info.plist文件删除掉多余的info.plist文件,重新编译即可(我是手动添加了Masonry的库,其中Masonry库中带有info.plist文件–删除) Multiple commands produce修改Xcode编译配置Xcode-&gt;File-&gt;Project Settings/Workspace Setting-&gt; Build System -&gt; Legacy Build System. Copy Pods Resources失效需要升级CocoaPods版本&gt;=1.4.0以上, 可见Github上的一个issues Xcode10 beta can’t load bundles from CocoaPods #解决ibrary not found for -lstdc++.6.0.9 真机：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/ 模拟器：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ 首先打开链接下载libstdc++.6.0.9.tbd；libstdc++.6.0.9.tbd下载地址密码：yc0m 进入到上述目录下，把libstdc++.6.0.9.tbd复制进去；]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之RN环境搭建]]></title>
    <url>%2F2018%2F10%2F10%2FiOS%E4%B9%8BRN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[React Native-iOS环境搭建 React Native 主要依赖以下环境: Mac OS X 操作系统 Xcode,推荐使用7.3.0或者更高系统 Node.js V6.2.1或者最新版本 Watchman和workflow NVM 下载Xcode，这个就不多讲了，直接在App Store下载即可安装Node.js，只要百度搜索Node.js，进入Node.js官网，直接下载安装Homebrew, 打开 Homebrew官网, 语言选择简体中文, 按照文档步骤进行安装即可打开终端依次输入命令：安装Homebrew:1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Node:123brew install node``` ### 安装Yarn npm install -g yarn react-native-cli1### 安装Watchman brew install watchman1### 安装Flow brew install flow12 brew update &amp;&amp; brew upgrade1### 安装NVM git clone https://github.com/creationix/nvm123``` cd nvm/``` ls123```source nvm.sh``` nvm123```nvm ls -remote N/A``` nvm ls12345## 环境搭建完毕 ## 创建项目 - 在桌面创建一个文件夹HelloWorld- 打开终端进入此文件夹（cd）- 终端输入: react-native init HelloWorld``` 在xcode中，使用快捷键cmd + R即可启动项目。基本的Xcode功能可以熟悉，比如模拟器的选择等。启动完成后，你会看到React-Packger和iOS模拟器，具体的效果如下，说明你创建项目成功了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F02%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[我的第一篇文章test – (实线) (虚线) 1.测试字体1.1测试字体(2018-2-6)本段为正文正文–（变斜）正文–（加粗），2018-2-8更新、本页跳转百度、本页跳转MacDown用法原链接。 分类：test 至 分类：learn 这两篇文章相隔甚久，期间发生了些什么呢，我也忘得差不多了，应该是在忙着开(fa)发(dai)吧😁。为啥开启第一篇呢，应该是过年将近，无需开发，只需光明正大的发呆就够了，嘻嘻嘻！第一篇文章我也不晓得写些啥子，但是还是想写，自从test文章结束后，我对于MacDown的用法还是非常陌生的，所以这次我还是先写(Command+C,Command+V)一篇MacDown的用法,当然上面也附上了原链接的地址，我可不是伸手党😝，为了给大家看看，主要还是为了自己之后写的时候还需要去百度，咦~~~，太low咯！！！ 2.下载链接 3.线框123线框第一行线框第二行线框第三行 4.列表无序列表 1(注意中间有空格) 2 3 有序列表 1(注意中间有空格) 2 3 5.连线5.1连线 1(注意中间有空格) 2 3 文字分割 5.2连线连线 1(注意中间有空格) 2 3 文字分割 前面有5个空格 5.3 连线 1(注意中间有空格) 2 3 6.表格第一行第一列第一行第二列第一行第三列第二行第一列第二行第二列,此格占2格第三行第一列，此格占3格 2018-2-8更新 1.删除效果删除 2.显示图片2.1显示网络图片2.2显示本地图片—这个方法有问题,显示不出,还不如直接将图片转为base64 3.表格使用新方法： 第一列 第二列 第三列 aaaa bbbb cccc 4.代码显示：leftView = [[UIView alloc]init]; 5.表示引用 一盏灯，一片黄昏； 6.特殊符号hello ©文字居中]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaoLuJun 的博客]]></title>
    <url>%2F2018%2F01%2F02%2Fblog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客！！！ 博客内容工作所得工作：iOS开发，平时做项目的时候，都会事先写一个demo，然后在合并到项目中去。当项目完成后，会将demo放到博客中来，也当做一种工作记录。 生活所得生活：发呆的生活。。。。。。。。。。。 心情心情：。。。。 链接My GitHub]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>maolujun</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
